# 参照元追加機能のパフォーマンス影響分析

**作成日**: 2025年1月  
**対象**: 回答内で言及されているページを参照元に追加する機能

---

## 実装方法

### 処理フロー

1. **回答内のパターン抽出**（軽量）
   - 正規表現で`（...）`パターンを抽出
   - 既存の`convertReferencesToNumberedLinks`と同じ処理

2. **既存参照元との比較**（軽量）
   - 抽出したタイトルが既存の参照元リストに含まれているかチェック
   - マッチングできないタイトルのみを抽出

3. **追加検索**（中程度の負荷）
   - マッチングできないタイトルを`searchLanceDB`で検索
   - タイトル検索（`exactTitleCandidates`パラメータを使用）

4. **参照元リストへの追加**（軽量）
   - 検索結果を参照元リストに追加

---

## パフォーマンスへの影響

### 1. 処理時間の見積もり

**軽量処理（回答内のパターン抽出と比較）**:
- 正規表現マッチング: < 1ms
- 配列操作（比較）: < 1ms
- **合計: < 2ms**

**追加検索（タイトル検索）**:
- Lunr検索（キャッシュヒット）: < 10ms
- Lunr検索（キャッシュミス）: 50-200ms
- LIKEクエリ（フォールバック）: 100-500ms（本番環境では遅い可能性）

**最悪ケース**:
- マッチングできないタイトルが5個ある場合
- すべてキャッシュミスで、LIKEクエリを使用
- **合計: 500-2500ms（0.5-2.5秒）**

### 2. 既存の最適化機能

✅ **キャッシュ機能**:
- `titleSearchCache`により、同じタイトルの検索結果をキャッシュ
- 2回目以降の検索は高速（< 10ms）

✅ **並列実行**:
- `Promise.all`により、複数のタイトル検索を並列実行
- 順次実行と比較して大幅に高速化

✅ **Lunr検索**:
- インデックスベースの高速検索
- LIKEクエリと比較して10-50倍高速

✅ **タイトル候補数の制限**:
- 既存実装では10個に制限
- 追加実装でも同様に制限可能

---

## 推奨される実装方法

### オプション1: バックグラウンド処理（推奨）

**メリット**:
- ストリーミング完了後のユーザー体験に影響しない
- 追加の参照元は後から非同期で追加

**実装**:
```typescript
// ストリーミング完了後、バックグラウンドで実行
setTimeout(async () => {
  const missingReferences = await findMissingReferences(answer, allReferences);
  if (missingReferences.length > 0) {
    // 参照元リストを更新（UIに反映）
    setReferences(prev => [...prev, ...missingReferences]);
  }
}, 0);
```

**パフォーマンス影響**: **最小限**（ユーザー体験に影響しない）

### オプション2: 同期処理（制限付き）

**メリット**:
- 即座に完全な参照元リストを提供

**デメリット**:
- ストリーミング完了後の処理時間が増加

**実装**:
```typescript
// ストリーミング完了時に実行
const missingReferences = await findMissingReferences(answer, allReferences, {
  maxSearches: 5, // 最大検索数を制限
  timeout: 1000, // 各検索に1秒のタイムアウト
  useCache: true // キャッシュを優先
});
```

**パフォーマンス影響**: **中程度**（0.5-2.5秒の追加時間）

### オプション3: ハイブリッド（推奨）

**実装**:
1. ストリーミング完了時に、キャッシュヒットする参照元のみを即座に追加
2. バックグラウンドで、キャッシュミスの参照元を検索して追加

**パフォーマンス影響**: **最小限**（キャッシュヒット分は即座に追加、ミス分は後から追加）

---

## 最適化策

### 1. 検索数の制限

```typescript
const MAX_ADDITIONAL_SEARCHES = 5; // 最大5個のタイトルを検索
const missingTitles = extractMissingTitles(answer, allReferences)
  .slice(0, MAX_ADDITIONAL_SEARCHES);
```

### 2. タイムアウトの設定

```typescript
const searchWithTimeout = async (title: string) => {
  return Promise.race([
    searchLanceDB({ query: title, exactTitleCandidates: [title] }),
    new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Timeout')), 500)
    )
  ]).catch(() => []); // タイムアウト時は空配列を返す
};
```

### 3. キャッシュの優先使用

```typescript
// キャッシュから取得を試行
const cachedResult = titleSearchCache.get(cacheKey);
if (cachedResult) {
  return cachedResult; // 即座に返す
}
```

### 4. バッチ処理

```typescript
// 複数のタイトルを一度に検索（既存の実装を活用）
const results = await searchLanceDB({
  query: '',
  exactTitleCandidates: missingTitles
});
```

---

## 結論

### パフォーマンスへの影響

**最小限の実装（オプション1: バックグラウンド処理）**:
- **ユーザー体験への影響**: なし
- **追加処理時間**: バックグラウンドで実行されるため、ユーザーは待たない
- **推奨度**: ⭐⭐⭐⭐⭐

**中程度の実装（オプション2: 同期処理）**:
- **ユーザー体験への影響**: 0.5-2.5秒の追加待機時間
- **追加処理時間**: キャッシュヒット率に依存
- **推奨度**: ⭐⭐⭐

**ハイブリッド実装（オプション3）**:
- **ユーザー体験への影響**: 最小限（キャッシュヒット分は即座に追加）
- **追加処理時間**: バックグラウンドで実行されるため、ユーザーは待たない
- **推奨度**: ⭐⭐⭐⭐⭐

### 推奨実装

**オプション3（ハイブリッド）**を推奨します：
1. ストリーミング完了時に、キャッシュヒットする参照元のみを即座に追加
2. バックグラウンドで、キャッシュミスの参照元を検索して追加
3. 検索数の制限（最大5個）とタイムアウト（各500ms）を設定

これにより、ユーザー体験への影響を最小限に抑えながら、参照元の完全性を向上させることができます。

