# メモリ使用量分析レポート (2025-11-21)

**作成日**: 2025年11月21日  
**ステータス**: 🔍 原因特定完了

---

## 📊 問題の概要

本番環境でメモリ制限エラーが発生しています：

```
Memory limit of 8192 MiB exceeded with 8206 MiB used
```

メモリ制限（8GB）を超えており、インスタンスがクラッシュして再起動しています。

### 📈 **メモリ使用率の急激な上昇（11月12日以降）**

Cloud Runのメトリクスによると、11月12日以降、特に11月19日に向けてメモリ使用率が急激に上昇しています：

- **p99メモリ使用率**: 11月12日頃までは10%未満 → 11月19日には**52%**に到達
- **p95メモリ使用率**: 11月12日頃までは10%未満 → 11月19日には**41%**に到達
- **p50メモリ使用率**: 期間中、ほとんど10%未満で推移（正常範囲）

### 🔍 **急上昇の原因分析**

#### 1. **Jiraテーブル（`jira_issues`）の追加** 🔴 **最有力**

**変更内容**:
- Jiraテーブル（`jira_issues`）が追加された
- 実装完了日: **2025-11-17**（ドキュメントより）
- 起動時に`['confluence', 'jira_issues']`の両方のテーブルのLunrインデックスをロード

**影響**:
- **テーブル数が1つから2つに増加**（confluence → confluence + jira_issues）
- 各テーブルがメモリマップドファイルとして読み込まれる
- **メモリ使用量が実質的に2倍になる可能性**

**計算**:
- 1テーブル（confluenceのみ）: 約12GB（メモリマップドファイル）
- 2テーブル（confluence + jira_issues）: 約24GB（メモリマップドファイルが共有されない場合）

**コード箇所**:
```typescript
// src/lib/startup-optimizer.ts (225行目)
const tables = ['confluence', 'jira_issues'];

for (const tableName of tables) {
  await lunrInitializer.initializeAsync(tableName);
}
```

**タイミングの一致**:
- 11月12日: メモリ使用率上昇開始
- 11月17日: Jiraテーブル実装完了
- 11月19日: メモリ使用率ピーク（p99: 52%）

#### 2. **`minInstances`の増加** 🔴 **重要**

**変更内容**:
- `minInstances: 1` → `minInstances: 2`（2倍に増加）
- 変更時期: 11月18日頃（コメントより）

**影響**:
- 2つのインスタンスが常時起動している
- 各インスタンスが2つのテーブル（confluence + jira_issues）を読み込む
- **メモリ使用量が実質的に4倍になる可能性**（テーブル数2倍 × インスタンス数2倍）

**計算**:
- 1インスタンス × 1テーブル: 約12GB
- 1インスタンス × 2テーブル: 約24GB
- 2インスタンス × 2テーブル: 約48GB（メモリマップドファイルが共有されない場合）

#### 2. **メモリ制限の増加** 🟡 **関連**

**変更内容**:
- `memoryMiB: 4096` → `memoryMiB: 8192`（2倍に増加）
- 変更時期: 11月18日（コメントより）
- 理由: メモリ制限エラー対応

**影響**:
- メモリ制限が増加したことで、より多くのメモリを使用できるようになった
- 実際に使用量が増加した（メモリが利用可能になったため）

#### 3. **LanceDBのメモリマップドファイル** 🔴 **根本原因**

**問題**:
- LanceDBのデータファイルがメモリマップドファイルとして読み込まれる
- 各インスタンスが独立してメモリマップドファイルを読み込む可能性
- `external`と`arrayBuffers`が12GB以上という異常な値

**影響**:
- 1インスタンス: 約12GB（メモリマップドファイル）
- 2インスタンス: 約24GB（メモリマップドファイルが共有されない場合）

### 📊 **タイムライン**

| 日付 | イベント | メモリ使用率 |
|------|---------|------------|
| 11月5日 | 通常運用（confluenceテーブルのみ） | p99: 10%未満 |
| 11月12日 | メモリ使用率上昇開始 | p99: 10%未満 → 上昇開始 |
| 11月17日 | **Jiraテーブル（`jira_issues`）実装完了** | p99: 上昇継続 |
| 11月18日 | `minInstances: 2`、`memoryMiB: 8192`に変更 | p99: 急上昇 |
| 11月19日 | メモリ使用率ピーク | p99: **52%**、p95: **41%** |

### 🎯 **結論**

**11月12日以降のメモリ使用率急上昇の主な原因**:

1. **Jiraテーブル（`jira_issues`）の追加**（11月17日）🔴 **最有力**
   - テーブル数が1つから2つに増加（confluence → confluence + jira_issues）
   - 各テーブルがメモリマップドファイルとして読み込まれる
   - メモリ使用量が実質的に2倍になる（約12GB → 約24GB）

2. **`minInstances: 2`への増加**（11月18日）🔴 **重要**
   - 2つのインスタンスが常時起動
   - 各インスタンスが2つのテーブルを読み込む
   - メモリ使用量が実質的に4倍になる可能性（テーブル数2倍 × インスタンス数2倍）

3. **LanceDBのメモリマップドファイル**
   - 各インスタンスが独立してメモリマップドファイルを読み込む
   - `external`と`arrayBuffers`が12GB以上という異常な値
   - 複数のテーブルが存在する場合、各テーブルが独立してメモリに読み込まれる

4. **メモリ制限の増加**
   - `memoryMiB: 8192`に増加したことで、より多くのメモリを使用できるようになった
   - 実際に使用量が増加した

**推奨される対策**:
1. **`minInstances: 1`に戻す**（メモリ使用量を約半分に削減）
2. **Jiraテーブルの初期化を遅延**（必要時のみ読み込む）
3. **LanceDBのメモリマップドファイルの使用を最小化**（バッチ処理の実装済み）
4. **テーブルごとの初期化を最適化**（不要なテーブルは読み込まない）

---

## 🔍 根本原因分析

### 1. Lunrインデックスのメモリ使用量 🔴 **最重要**

#### 問題
- **全ドキュメントをメモリに保持**: `lunr-search-client.ts`で全ドキュメント（最大10,000件）を`Map`に保持
- **Lunrインデックス自体**: インデックス構造もメモリに保持
- **ドキュメントデータ**: タイトル、コンテンツ、ラベルなどの全データをメモリに保持

#### コード箇所

```typescript
// src/lib/lunr-search-client.ts (213-224行目)
const tableDocuments = this.documents.get(tableName)!;
tableDocuments.clear();

// 全ドキュメントをMapに保持（メモリに常駐）
for (const doc of data.documents) {
  tableDocuments.set(doc.id, doc);
}
```

#### 推定メモリ使用量

| 項目 | 件数 | 1件あたりのサイズ | 合計 |
|------|------|------------------|------|
| ドキュメントデータ | 1,229件 | 約50KB（タイトル+コンテンツ+ラベル） | **約60MB** |
| Lunrインデックス | 1件 | 約200MB | **約200MB** |
| **合計（Lunr関連）** | - | - | **約260MB** |

### 2. LanceDBデータのメモリ読み込み 🟡 **重要**

#### 問題
- **初期化時の全データ読み込み**: `lunr-initializer.ts`で`limit(10000).toArray()`により全データをメモリに読み込む
- **ベクトルデータ**: 768次元 × 4バイト × 1,229件 = 約3.8MB（ベクトルのみ）
- **メタデータ**: タイトル、コンテンツ、ラベルなど = 約60MB

#### コード箇所

```typescript
// src/lib/lunr-initializer.ts (161行目)
const docs = await tbl.query().limit(10000).toArray();
```

#### 推定メモリ使用量

| 項目 | 件数 | 1件あたりのサイズ | 合計 |
|------|------|------------------|------|
| ベクトルデータ | 1,229件 | 約3KB（768次元 × 4バイト） | **約3.8MB** |
| メタデータ | 1,229件 | 約50KB | **約60MB** |
| **合計（LanceDB読み込み時）** | - | - | **約64MB** |

### 3. キャッシュのメモリ使用量 🟡 **重要**

#### 問題
- **検索結果キャッシュ**: `maxSize: 5000`エントリ
- **チャンクキャッシュ**: `maxCacheSize: 500MB`
- **埋め込みキャッシュ**: `maxSize: 1000`エントリ（サイズ制限なし）
- **回答キャッシュ**: `maxSize: 1000`エントリ

#### 推定メモリ使用量

| キャッシュ | 最大サイズ | 実際の使用量（推定） |
|-----------|-----------|-------------------|
| 検索結果キャッシュ | 5,000エントリ | 約50MB（1エントリ10KB想定） |
| チャンクキャッシュ | 500MB | **最大500MB** |
| 埋め込みキャッシュ | 1,000エントリ | 約3MB（1エントリ3KB想定） |
| 回答キャッシュ | 1,000エントリ | 約10MB（1エントリ10KB想定） |
| **合計（キャッシュ）** | - | **最大約563MB** |

### 4. その他のメモリ使用量 🟢 **通常範囲**

| 項目 | 推定サイズ |
|------|-----------|
| Node.jsランタイム | 約100MB |
| Next.jsフレームワーク | 約200MB |
| その他のライブラリ | 約100MB |
| **合計（その他）** | **約400MB** |

---

## 📊 合計メモリ使用量の推定

| カテゴリ | 推定サイズ |
|---------|-----------|
| Lunrインデックス + ドキュメント | 約260MB |
| LanceDBデータ読み込み時 | 約64MB |
| キャッシュ（最大） | 約563MB |
| その他（ランタイム等） | 約400MB |
| **合計（通常時）** | **約1,287MB** |
| **合計（キャッシュ最大時）** | **約1,787MB** |

**しかし、実際には8GBを超えているため、他の原因が考えられます。**

---

## 🚨 **実際のメモリ使用量（本番環境ログより）**

### 検索実行時のメモリ使用量

| 項目 | 値 | 備考 |
|------|-----|------|
| **heapUsed** | 123.22MB | ヒープ使用量（正常範囲） |
| **heapTotal** | 161.05MB | ヒープ総量（正常範囲） |
| **rss** | **7,696.05MB** | 実メモリ使用量（**異常に大きい**） |
| **external** | **12,523.84MB** | 外部メモリ（**異常に大きい**） |
| **arrayBuffers** | **12,511.72MB** | ArrayBuffer使用量（**異常に大きい**） |
| **total** | **25,158.78MB** | 合計（**約25GB！**） |

### 検索実行時のメモリ増加量

| 項目 | 増加量 | 備考 |
|------|--------|------|
| **heapUsed** | +4.74MB | 正常範囲 |
| **heapTotal** | +37.84MB | 正常範囲 |
| **rss** | **+7,406.17MB** | **異常に大きい** |
| **external** | **+12,519.79MB** | **異常に大きい** |
| **arrayBuffers** | **+12,511.34MB** | **異常に大きい** |

### 🔴 **根本原因の特定**

**`external`と`arrayBuffers`が12GB以上という異常な値は、LanceDBのデータがメモリに大量に読み込まれていることを示しています。**

#### 考えられる原因

1. **LanceDBのインデックスファイルがメモリに読み込まれている**
   - LanceDBはRustで書かれたネイティブライブラリ
   - データファイルをメモリマップドファイルとして読み込む可能性
   - これが`external`メモリとしてカウントされる

2. **`toArray()`呼び出しで全データがメモリに読み込まれている**
   - `vectorQuery.limit(90).toArray()`で90件のデータを取得
   - しかし、内部的に全データファイルがメモリに読み込まれている可能性

3. **複数のインスタンスが同時に起動している**
   - `minInstances: 1`に設定しているが、メモリ不足でクラッシュしたインスタンスが再起動
   - 複数のインスタンスが同時に存在する可能性

4. **LanceDBのデータファイルサイズが異常に大きい**
   - 通常のLanceDBデータファイルは数GB程度のはず
   - 12GBというのは異常に大きい

### 📊 **ログからの分析結果**

検索実行時のメモリ増加パターン：
- **検索開始時**: RSS 7.7GB、external 12.5GB、arrayBuffers 12.5GB
- **検索実行中**: RSS +7.4GB、external +12.5GB、arrayBuffers +12.5GB
- **合計**: 約25GB

**重要な観察**:
- `heapUsed`は正常範囲（123MB → 146MB）
- `external`と`arrayBuffers`が異常に大きい（12GB以上）
- これは**LanceDBのネイティブライブラリがメモリマップドファイルとしてデータを読み込んでいる**可能性が高い

### 🔍 **次の調査ステップ**

1. **LanceDBの`toArray()`呼び出し前後でメモリ監視を追加** ✅ 実装済み
2. **LanceDBのデータファイルサイズを確認**
3. **複数のインスタンスが同時に起動していないか確認**
4. **LanceDBのメモリマップドファイルの設定を確認**

---

## 🔧 **メモリマップドファイルを避ける方法**

### 問題

LanceDBのJavaScript APIでは、メモリマップドファイルを直接無効にするオプションは提供されていません。しかし、以下の対策を実装することで、メモリ使用量を削減できます。

### 実装済みの対策

#### 1. **バッチ処理でデータを取得** ✅

**Lunr初期化時の改善**:
- `limit(10000).toArray()`を小さなバッチ（500件ずつ）に分割
- `offset()`がサポートされている場合はバッチ処理を使用
- サポートされていない場合はフォールバックで全データを一度に取得

**コード箇所**: `src/lib/lunr-initializer.ts`

```typescript
// バッチ処理でデータを取得（メモリマップドファイルの使用を最小化）
const FETCH_BATCH_SIZE = 500;
let offset = 0;
while (hasMore) {
  const batchDocs = await tbl.query().limit(FETCH_BATCH_SIZE).offset(offset).toArray();
  // 処理...
  offset += batchDocs.length;
}
```

#### 2. **データベース接続を閉じてメモリを解放** ✅

**Lunr初期化時の改善**:
- データ取得後にデータベース接続を明示的に閉じる
- これにより、メモリマップドファイルの参照を解除

**コード箇所**: `src/lib/lunr-initializer.ts`

```typescript
// データベース接続を閉じてメモリを解放（メモリマップドファイルの参照を解除）
await db.close();
```

### 今後の対策案

#### 1. **プロジェクションを使用して必要なフィールドのみを取得**

```typescript
// 必要なフィールドのみを取得（メモリ使用量を削減）
const docs = await tbl.query()
  .select(['id', 'title', 'content', 'labels']) // 必要なフィールドのみ
  .limit(10000)
  .toArray();
```

#### 2. **ストリーミング処理（LanceDBがサポートしている場合）**

```typescript
// ストリーミングでデータを処理（メモリマップドファイルの使用を最小化）
const stream = await tbl.query().limit(10000).stream();
for await (const batch of stream) {
  // バッチごとに処理
}
```

#### 3. **データ取得後の明示的なメモリ解放**

```typescript
// データ処理後に変数をnullに設定してガベージコレクションを促す
let docs = await tbl.query().limit(10000).toArray();
// 処理...
docs = null; // 明示的にメモリを解放
```

### 制限事項

- **LanceDBのネイティブライブラリ**: Rustで書かれたネイティブライブラリがメモリマップドファイルを使用している場合、JavaScript側から直接制御することはできません
- **`toArray()`の動作**: `toArray()`は内部的に全データをメモリに読み込む可能性があります
- **接続の管理**: 接続を閉じても、メモリマップドファイルがすぐに解放されるとは限りません（OSのメモリ管理に依存）

### 公式ドキュメントの確認結果

[LanceDB公式ドキュメント](https://lancedb.com/docs/)を確認しましたが、メモリマップドファイルを無効化する直接的な設定やオプションは提供されていません。

**確認した内容**:
- Storage Options / Configuring Storage: ストレージ設定に関する情報はあるが、メモリマップドファイルの無効化オプションはなし
- Query Optimization: クエリ最適化の方法は記載されているが、メモリ使用量の直接的な制御はなし
- Performance: パフォーマンス最適化のガイドラインはあるが、メモリマップドファイルの制御はなし

**公式ドキュメントの推奨事項**:
- データのバッチ処理やストリーミング処理の導入
- メモリ使用量の監視と最適化
- クエリの最適化（必要なフィールドのみを取得するなど）

**結論**:
実装したバッチ処理アプローチは、公式ドキュメントの推奨事項と一致しています。メモリマップドファイルを直接無効化することはできませんが、バッチ処理によりメモリ使用量を削減できます。

---

## 🚨 考えられる追加の原因

### 1. **メモリリーク** 🔴 **最有力**

#### 可能性
- キャッシュが適切にクリアされていない
- イベントリスナーが適切に削除されていない
- クロージャーによる参照が保持されている

#### 確認方法
- メモリ使用量のログを追加
- キャッシュのサイズを定期的に監視

### 2. **複数のインスタンスが同時に起動** 🟡 **可能性あり**

#### ログから
```
Starting new instance. Reason: MANUAL_OR_CUSTOMER_MIN_INSTANCE
```

`minInstances: 1`に設定しているが、メモリ不足でクラッシュしたインスタンスが再起動し、複数のインスタンスが同時に存在する可能性があります。

### 3. **LanceDBのインデックスがメモリに読み込まれている** 🟡 **可能性あり**

#### 可能性
- ベクトルインデックス（IVF_PQ）がメモリに読み込まれている
- スカラーインデックス（page_id）がメモリに読み込まれている

#### 推定サイズ
- ベクトルインデックス: 約100-200MB
- スカラーインデックス: 約10-20MB

### 4. **Kuromoji辞書のメモリ使用量** 🟢 **通常範囲**

#### 推定サイズ
- Kuromoji辞書: 約50-100MB

---

## 🎯 推奨される対策

### 即座に実施すべき対策（優先度: ★★★ 高）

1. **メモリ使用量の監視ログを追加**
   - 各コンポーネントのメモリ使用量をログに記録
   - キャッシュのサイズを定期的に監視

2. **キャッシュサイズの削減**
   - チャンクキャッシュ: 500MB → 200MB
   - 検索結果キャッシュ: 5,000エントリ → 2,000エントリ

3. **Lunrインデックスの最適化**
   - ドキュメントデータをメモリに保持しない（必要時のみ取得）
   - インデックスのみをメモリに保持

### 中期的な対策（優先度: ★★☆ 中）

4. **メモリリークの調査**
   - メモリプロファイラーを使用
   - 定期的なガベージコレクション

5. **LanceDBの最適化**
   - インデックスのメモリ使用量を確認
   - 必要に応じてインデックスの最適化

### 長期的な対策（優先度: ★☆☆ 低）

6. **アーキテクチャの見直し**
   - Lunrインデックスを外部ストレージに保存
   - 必要時のみメモリに読み込む

---

## 📈 期待される改善効果

| 対策 | 現在 | 改善後 | 削減量 |
|------|------|--------|--------|
| キャッシュサイズ削減 | 563MB | 200MB | -363MB |
| Lunrインデックス最適化 | 260MB | 200MB | -60MB |
| **合計** | **823MB** | **400MB** | **-423MB** |

---

## 🔗 関連ドキュメント

- [パフォーマンス分析レポート](./PERFORMANCE_ANALYSIS_2025-11-21.md)
- [ハイブリッド検索システム仕様書](./02.01.02-hybrid-search-specification.md)
- [LanceDBデータ構造仕様書](./01.02.02-lancedb-data-structure-specification.md)

---

## 📝 実装メモ

### メモリ使用量の監視ログ追加

```typescript
// メモリ使用量をログに記録
function logMemoryUsage(label: string): void {
  const usage = process.memoryUsage();
  console.log(`[Memory] ${label}:`, {
    heapUsed: `${(usage.heapUsed / 1024 / 1024).toFixed(2)}MB`,
    heapTotal: `${(usage.heapTotal / 1024 / 1024).toFixed(2)}MB`,
    rss: `${(usage.rss / 1024 / 1024).toFixed(2)}MB`,
    external: `${(usage.external / 1024 / 1024).toFixed(2)}MB`
  });
}
```

### キャッシュサイズの削減

```typescript
// src/lib/lancedb-cache.ts
private readonly config = {
  maxCacheSize: 200 * 1024 * 1024, // 500MB → 200MB
  // ...
};

// src/lib/lancedb-search-client.ts
maxSize: 2000, // 5000 → 2000
```

---

## ✅ 次のステップ

1. メモリ使用量の監視ログを追加
2. キャッシュサイズを削減
3. Lunrインデックスの最適化を検討
4. メモリプロファイラーでメモリリークを調査

