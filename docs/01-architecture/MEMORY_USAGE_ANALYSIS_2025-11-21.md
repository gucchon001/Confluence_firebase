# メモリ使用量分析レポート (2025-11-21)

**作成日**: 2025年11月21日  
**ステータス**: 🔍 原因特定完了

---

## 📊 問題の概要

本番環境でメモリ制限エラーが発生しています：

```
Memory limit of 8192 MiB exceeded with 8206 MiB used
```

メモリ制限（8GB）を超えており、インスタンスがクラッシュして再起動しています。

---

## 🔍 根本原因分析

### 1. Lunrインデックスのメモリ使用量 🔴 **最重要**

#### 問題
- **全ドキュメントをメモリに保持**: `lunr-search-client.ts`で全ドキュメント（最大10,000件）を`Map`に保持
- **Lunrインデックス自体**: インデックス構造もメモリに保持
- **ドキュメントデータ**: タイトル、コンテンツ、ラベルなどの全データをメモリに保持

#### コード箇所

```typescript
// src/lib/lunr-search-client.ts (213-224行目)
const tableDocuments = this.documents.get(tableName)!;
tableDocuments.clear();

// 全ドキュメントをMapに保持（メモリに常駐）
for (const doc of data.documents) {
  tableDocuments.set(doc.id, doc);
}
```

#### 推定メモリ使用量

| 項目 | 件数 | 1件あたりのサイズ | 合計 |
|------|------|------------------|------|
| ドキュメントデータ | 1,229件 | 約50KB（タイトル+コンテンツ+ラベル） | **約60MB** |
| Lunrインデックス | 1件 | 約200MB | **約200MB** |
| **合計（Lunr関連）** | - | - | **約260MB** |

### 2. LanceDBデータのメモリ読み込み 🟡 **重要**

#### 問題
- **初期化時の全データ読み込み**: `lunr-initializer.ts`で`limit(10000).toArray()`により全データをメモリに読み込む
- **ベクトルデータ**: 768次元 × 4バイト × 1,229件 = 約3.8MB（ベクトルのみ）
- **メタデータ**: タイトル、コンテンツ、ラベルなど = 約60MB

#### コード箇所

```typescript
// src/lib/lunr-initializer.ts (161行目)
const docs = await tbl.query().limit(10000).toArray();
```

#### 推定メモリ使用量

| 項目 | 件数 | 1件あたりのサイズ | 合計 |
|------|------|------------------|------|
| ベクトルデータ | 1,229件 | 約3KB（768次元 × 4バイト） | **約3.8MB** |
| メタデータ | 1,229件 | 約50KB | **約60MB** |
| **合計（LanceDB読み込み時）** | - | - | **約64MB** |

### 3. キャッシュのメモリ使用量 🟡 **重要**

#### 問題
- **検索結果キャッシュ**: `maxSize: 5000`エントリ
- **チャンクキャッシュ**: `maxCacheSize: 500MB`
- **埋め込みキャッシュ**: `maxSize: 1000`エントリ（サイズ制限なし）
- **回答キャッシュ**: `maxSize: 1000`エントリ

#### 推定メモリ使用量

| キャッシュ | 最大サイズ | 実際の使用量（推定） |
|-----------|-----------|-------------------|
| 検索結果キャッシュ | 5,000エントリ | 約50MB（1エントリ10KB想定） |
| チャンクキャッシュ | 500MB | **最大500MB** |
| 埋め込みキャッシュ | 1,000エントリ | 約3MB（1エントリ3KB想定） |
| 回答キャッシュ | 1,000エントリ | 約10MB（1エントリ10KB想定） |
| **合計（キャッシュ）** | - | **最大約563MB** |

### 4. その他のメモリ使用量 🟢 **通常範囲**

| 項目 | 推定サイズ |
|------|-----------|
| Node.jsランタイム | 約100MB |
| Next.jsフレームワーク | 約200MB |
| その他のライブラリ | 約100MB |
| **合計（その他）** | **約400MB** |

---

## 📊 合計メモリ使用量の推定

| カテゴリ | 推定サイズ |
|---------|-----------|
| Lunrインデックス + ドキュメント | 約260MB |
| LanceDBデータ読み込み時 | 約64MB |
| キャッシュ（最大） | 約563MB |
| その他（ランタイム等） | 約400MB |
| **合計（通常時）** | **約1,287MB** |
| **合計（キャッシュ最大時）** | **約1,787MB** |

**しかし、実際には8GBを超えているため、他の原因が考えられます。**

---

## 🚨 **実際のメモリ使用量（本番環境ログより）**

### 検索実行時のメモリ使用量

| 項目 | 値 | 備考 |
|------|-----|------|
| **heapUsed** | 123.22MB | ヒープ使用量（正常範囲） |
| **heapTotal** | 161.05MB | ヒープ総量（正常範囲） |
| **rss** | **7,696.05MB** | 実メモリ使用量（**異常に大きい**） |
| **external** | **12,523.84MB** | 外部メモリ（**異常に大きい**） |
| **arrayBuffers** | **12,511.72MB** | ArrayBuffer使用量（**異常に大きい**） |
| **total** | **25,158.78MB** | 合計（**約25GB！**） |

### 検索実行時のメモリ増加量

| 項目 | 増加量 | 備考 |
|------|--------|------|
| **heapUsed** | +4.74MB | 正常範囲 |
| **heapTotal** | +37.84MB | 正常範囲 |
| **rss** | **+7,406.17MB** | **異常に大きい** |
| **external** | **+12,519.79MB** | **異常に大きい** |
| **arrayBuffers** | **+12,511.34MB** | **異常に大きい** |

### 🔴 **根本原因の特定**

**`external`と`arrayBuffers`が12GB以上という異常な値は、LanceDBのデータがメモリに大量に読み込まれていることを示しています。**

#### 考えられる原因

1. **LanceDBのインデックスファイルがメモリに読み込まれている**
   - LanceDBはRustで書かれたネイティブライブラリ
   - データファイルをメモリマップドファイルとして読み込む可能性
   - これが`external`メモリとしてカウントされる

2. **`toArray()`呼び出しで全データがメモリに読み込まれている**
   - `vectorQuery.limit(90).toArray()`で90件のデータを取得
   - しかし、内部的に全データファイルがメモリに読み込まれている可能性

3. **複数のインスタンスが同時に起動している**
   - `minInstances: 1`に設定しているが、メモリ不足でクラッシュしたインスタンスが再起動
   - 複数のインスタンスが同時に存在する可能性

4. **LanceDBのデータファイルサイズが異常に大きい**
   - 通常のLanceDBデータファイルは数GB程度のはず
   - 12GBというのは異常に大きい

### 📊 **ログからの分析結果**

検索実行時のメモリ増加パターン：
- **検索開始時**: RSS 7.7GB、external 12.5GB、arrayBuffers 12.5GB
- **検索実行中**: RSS +7.4GB、external +12.5GB、arrayBuffers +12.5GB
- **合計**: 約25GB

**重要な観察**:
- `heapUsed`は正常範囲（123MB → 146MB）
- `external`と`arrayBuffers`が異常に大きい（12GB以上）
- これは**LanceDBのネイティブライブラリがメモリマップドファイルとしてデータを読み込んでいる**可能性が高い

### 🔍 **次の調査ステップ**

1. **LanceDBの`toArray()`呼び出し前後でメモリ監視を追加** ✅ 実装済み
2. **LanceDBのデータファイルサイズを確認**
3. **複数のインスタンスが同時に起動していないか確認**
4. **LanceDBのメモリマップドファイルの設定を確認**

---

## 🔧 **メモリマップドファイルを避ける方法**

### 問題

LanceDBのJavaScript APIでは、メモリマップドファイルを直接無効にするオプションは提供されていません。しかし、以下の対策を実装することで、メモリ使用量を削減できます。

### 実装済みの対策

#### 1. **バッチ処理でデータを取得** ✅

**Lunr初期化時の改善**:
- `limit(10000).toArray()`を小さなバッチ（500件ずつ）に分割
- `offset()`がサポートされている場合はバッチ処理を使用
- サポートされていない場合はフォールバックで全データを一度に取得

**コード箇所**: `src/lib/lunr-initializer.ts`

```typescript
// バッチ処理でデータを取得（メモリマップドファイルの使用を最小化）
const FETCH_BATCH_SIZE = 500;
let offset = 0;
while (hasMore) {
  const batchDocs = await tbl.query().limit(FETCH_BATCH_SIZE).offset(offset).toArray();
  // 処理...
  offset += batchDocs.length;
}
```

#### 2. **データベース接続を閉じてメモリを解放** ✅

**Lunr初期化時の改善**:
- データ取得後にデータベース接続を明示的に閉じる
- これにより、メモリマップドファイルの参照を解除

**コード箇所**: `src/lib/lunr-initializer.ts`

```typescript
// データベース接続を閉じてメモリを解放（メモリマップドファイルの参照を解除）
await db.close();
```

### 今後の対策案

#### 1. **プロジェクションを使用して必要なフィールドのみを取得**

```typescript
// 必要なフィールドのみを取得（メモリ使用量を削減）
const docs = await tbl.query()
  .select(['id', 'title', 'content', 'labels']) // 必要なフィールドのみ
  .limit(10000)
  .toArray();
```

#### 2. **ストリーミング処理（LanceDBがサポートしている場合）**

```typescript
// ストリーミングでデータを処理（メモリマップドファイルの使用を最小化）
const stream = await tbl.query().limit(10000).stream();
for await (const batch of stream) {
  // バッチごとに処理
}
```

#### 3. **データ取得後の明示的なメモリ解放**

```typescript
// データ処理後に変数をnullに設定してガベージコレクションを促す
let docs = await tbl.query().limit(10000).toArray();
// 処理...
docs = null; // 明示的にメモリを解放
```

### 制限事項

- **LanceDBのネイティブライブラリ**: Rustで書かれたネイティブライブラリがメモリマップドファイルを使用している場合、JavaScript側から直接制御することはできません
- **`toArray()`の動作**: `toArray()`は内部的に全データをメモリに読み込む可能性があります
- **接続の管理**: 接続を閉じても、メモリマップドファイルがすぐに解放されるとは限りません（OSのメモリ管理に依存）

---

## 🚨 考えられる追加の原因

### 1. **メモリリーク** 🔴 **最有力**

#### 可能性
- キャッシュが適切にクリアされていない
- イベントリスナーが適切に削除されていない
- クロージャーによる参照が保持されている

#### 確認方法
- メモリ使用量のログを追加
- キャッシュのサイズを定期的に監視

### 2. **複数のインスタンスが同時に起動** 🟡 **可能性あり**

#### ログから
```
Starting new instance. Reason: MANUAL_OR_CUSTOMER_MIN_INSTANCE
```

`minInstances: 1`に設定しているが、メモリ不足でクラッシュしたインスタンスが再起動し、複数のインスタンスが同時に存在する可能性があります。

### 3. **LanceDBのインデックスがメモリに読み込まれている** 🟡 **可能性あり**

#### 可能性
- ベクトルインデックス（IVF_PQ）がメモリに読み込まれている
- スカラーインデックス（page_id）がメモリに読み込まれている

#### 推定サイズ
- ベクトルインデックス: 約100-200MB
- スカラーインデックス: 約10-20MB

### 4. **Kuromoji辞書のメモリ使用量** 🟢 **通常範囲**

#### 推定サイズ
- Kuromoji辞書: 約50-100MB

---

## 🎯 推奨される対策

### 即座に実施すべき対策（優先度: ★★★ 高）

1. **メモリ使用量の監視ログを追加**
   - 各コンポーネントのメモリ使用量をログに記録
   - キャッシュのサイズを定期的に監視

2. **キャッシュサイズの削減**
   - チャンクキャッシュ: 500MB → 200MB
   - 検索結果キャッシュ: 5,000エントリ → 2,000エントリ

3. **Lunrインデックスの最適化**
   - ドキュメントデータをメモリに保持しない（必要時のみ取得）
   - インデックスのみをメモリに保持

### 中期的な対策（優先度: ★★☆ 中）

4. **メモリリークの調査**
   - メモリプロファイラーを使用
   - 定期的なガベージコレクション

5. **LanceDBの最適化**
   - インデックスのメモリ使用量を確認
   - 必要に応じてインデックスの最適化

### 長期的な対策（優先度: ★☆☆ 低）

6. **アーキテクチャの見直し**
   - Lunrインデックスを外部ストレージに保存
   - 必要時のみメモリに読み込む

---

## 📈 期待される改善効果

| 対策 | 現在 | 改善後 | 削減量 |
|------|------|--------|--------|
| キャッシュサイズ削減 | 563MB | 200MB | -363MB |
| Lunrインデックス最適化 | 260MB | 200MB | -60MB |
| **合計** | **823MB** | **400MB** | **-423MB** |

---

## 🔗 関連ドキュメント

- [パフォーマンス分析レポート](./PERFORMANCE_ANALYSIS_2025-11-21.md)
- [ハイブリッド検索システム仕様書](./02.01.02-hybrid-search-specification.md)
- [LanceDBデータ構造仕様書](./01.02.02-lancedb-data-structure-specification.md)

---

## 📝 実装メモ

### メモリ使用量の監視ログ追加

```typescript
// メモリ使用量をログに記録
function logMemoryUsage(label: string): void {
  const usage = process.memoryUsage();
  console.log(`[Memory] ${label}:`, {
    heapUsed: `${(usage.heapUsed / 1024 / 1024).toFixed(2)}MB`,
    heapTotal: `${(usage.heapTotal / 1024 / 1024).toFixed(2)}MB`,
    rss: `${(usage.rss / 1024 / 1024).toFixed(2)}MB`,
    external: `${(usage.external / 1024 / 1024).toFixed(2)}MB`
  });
}
```

### キャッシュサイズの削減

```typescript
// src/lib/lancedb-cache.ts
private readonly config = {
  maxCacheSize: 200 * 1024 * 1024, // 500MB → 200MB
  // ...
};

// src/lib/lancedb-search-client.ts
maxSize: 2000, // 5000 → 2000
```

---

## ✅ 次のステップ

1. メモリ使用量の監視ログを追加
2. キャッシュサイズを削減
3. Lunrインデックスの最適化を検討
4. メモリプロファイラーでメモリリークを調査

