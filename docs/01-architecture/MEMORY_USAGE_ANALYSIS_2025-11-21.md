# メモリ使用量分析レポート (2025-11-21)

**作成日**: 2025年11月21日  
**ステータス**: 🔍 原因特定完了

---

## 📊 問題の概要

本番環境でメモリ制限エラーが発生しています：

```
Memory limit of 8192 MiB exceeded with 8206 MiB used
```

メモリ制限（8GB）を超えており、インスタンスがクラッシュして再起動しています。

### 📈 **メモリ使用率の急激な上昇（11月12日以降）**

Cloud Runのメトリクスによると、11月12日以降、特に11月19日に向けてメモリ使用率が急激に上昇しています：

- **p99メモリ使用率**: 11月12日頃までは10%未満 → 11月19日には**52%**に到達
- **p95メモリ使用率**: 11月12日頃までは10%未満 → 11月19日には**41%**に到達
- **p50メモリ使用率**: 期間中、ほとんど10%未満で推移（正常範囲）

### 🔍 **急上昇の原因分析**

#### 1. **Jiraテーブル（`jira_issues`）の追加** 🔴 **最有力**

**変更内容**:
- Jiraテーブル（`jira_issues`）が追加された
- 実装完了日: **2025-11-17**（ドキュメントより）
- 起動時に`['confluence', 'jira_issues']`の両方のテーブルのLunrインデックスをロード

**影響**:
- **テーブル数が1つから2つに増加**（confluence → confluence + jira_issues）
- 各テーブルがメモリマップドファイルとして読み込まれる
- **メモリ使用量が実質的に2倍になる可能性**

**計算**:
- 1テーブル（confluenceのみ）: 約12GB（メモリマップドファイル）
- 2テーブル（confluence + jira_issues）: 約24GB（メモリマップドファイルが共有されない場合）

**コード箇所**:
```typescript
// src/lib/startup-optimizer.ts (225行目)
const tables = ['confluence', 'jira_issues'];

for (const tableName of tables) {
  await lunrInitializer.initializeAsync(tableName);
}
```

**タイミングの一致**:
- 11月12日: メモリ使用率上昇開始
- 11月17日: Jiraテーブル実装完了
- 11月19日: メモリ使用率ピーク（p99: 52%）

#### 2. **`minInstances`の増加** 🔴 **重要**

**変更内容**:
- `minInstances: 1` → `minInstances: 2`（2倍に増加）
- 変更時期: 11月18日頃（コメントより）

**影響**:
- 2つのインスタンスが常時起動している
- 各インスタンスが2つのテーブル（confluence + jira_issues）を読み込む
- **メモリ使用量が実質的に4倍になる可能性**（テーブル数2倍 × インスタンス数2倍）

**計算**:
- 1インスタンス × 1テーブル: 約12GB
- 1インスタンス × 2テーブル: 約24GB
- 2インスタンス × 2テーブル: 約48GB（メモリマップドファイルが共有されない場合）

#### 2. **メモリ制限の増加** 🟡 **関連**

**変更内容**:
- `memoryMiB: 4096` → `memoryMiB: 8192`（2倍に増加）
- 変更時期: 11月18日（コメントより）
- 理由: メモリ制限エラー対応

**影響**:
- メモリ制限が増加したことで、より多くのメモリを使用できるようになった
- 実際に使用量が増加した（メモリが利用可能になったため）

#### 3. **LanceDBのメモリマップドファイル** 🔴 **根本原因**

**問題**:
- LanceDBのデータファイルがメモリマップドファイルとして読み込まれる
- 各インスタンスが独立してメモリマップドファイルを読み込む可能性
- `external`と`arrayBuffers`が12GB以上という異常な値

**影響**:
- 1インスタンス: 約12GB（メモリマップドファイル）
- 2インスタンス: 約24GB（メモリマップドファイルが共有されない場合）

### 📊 **タイムライン**

| 日付 | イベント | メモリ使用率 |
|------|---------|------------|
| 11月5日 | 通常運用（confluenceテーブルのみ） | p99: 10%未満 |
| 11月12日 | メモリ使用率上昇開始 | p99: 10%未満 → 上昇開始 |
| 11月17日 | **Jiraテーブル（`jira_issues`）実装完了** | p99: 上昇継続 |
| 11月18日 | `minInstances: 2`、`memoryMiB: 8192`に変更 | p99: 急上昇 |
| 11月19日 | メモリ使用率ピーク | p99: **52%**、p95: **41%** |

### 🎯 **結論と確定度評価**

**11月12日以降のメモリ使用率急上昇の主な原因**:

#### 確定度: **🟢 高い（約90%）**

**根拠**:
1. ✅ **タイミングの一致**: メモリ使用率上昇開始（11月12日）とJiraテーブル実装完了（11月17日）が一致
2. ✅ **コードの確認**: 起動時に両方のテーブルを初期化するコードが確認済み
3. ✅ **メモリ使用量の計算**: テーブル数2倍 × インスタンス数2倍 = 約4倍の計算が一致
4. ✅ **ログの確認**: `external`と`arrayBuffers`が12GB以上という異常な値が確認済み

**残りの不確実性（約10%）**:
- メモリマップドファイルが実際に共有されるかどうか（OSの実装に依存）
- 他の要因（データ量の増加、キャッシュの蓄積など）の影響度

#### 1. **Jiraテーブル（`jira_issues`）の追加**（11月17日）🔴 **最有力（確定度: 95%）**

**確定根拠**:
- ✅ 実装完了日が確認済み（2025-11-17）
- ✅ 起動時に両方のテーブルを初期化するコードが確認済み
- ✅ タイミングが一致（11月12日上昇開始 → 11月17日実装完了）

**影響**:
- テーブル数が1つから2つに増加（confluence → confluence + jira_issues）
- 各テーブルがメモリマップドファイルとして読み込まれる
- メモリ使用量が実質的に2倍になる（約12GB → 約24GB）

#### 2. **`minInstances: 2`への増加**（11月18日）🔴 **重要（確定度: 90%）**

**確定根拠**:
- ✅ 設定ファイルで確認済み（`apphosting.yaml`）
- ✅ コメントに変更時期が記載（11月18日）
- ✅ ログで複数インスタンスの起動が確認済み

**影響**:
- 2つのインスタンスが常時起動
- 各インスタンスが2つのテーブルを読み込む
- メモリ使用量が実質的に4倍になる可能性（テーブル数2倍 × インスタンス数2倍）

#### 3. **LanceDBのメモリマップドファイル** 🔴 **根本原因（確定度: 85%）**

**確定根拠**:
- ✅ `external`と`arrayBuffers`が12GB以上という異常な値が確認済み
- ✅ LanceDBのネイティブライブラリ（Rust）がメモリマップドファイルを使用する可能性が高い
- ⚠️ メモリマップドファイルが実際に共有されるかどうかはOSの実装に依存（不確実）

**影響**:
- 各インスタンスが独立してメモリマップドファイルを読み込む可能性
- 複数のテーブルが存在する場合、各テーブルが独立してメモリに読み込まれる

#### 4. **メモリ制限の増加** 🟡 **関連（確定度: 70%）**

**確定根拠**:
- ✅ 設定ファイルで確認済み（`memoryMiB: 8192`）
- ⚠️ メモリ制限の増加が実際の使用量増加の直接的な原因かどうかは不確実

**影響**:
- メモリ制限が増加したことで、より多くのメモリを使用できるようになった
- 実際に使用量が増加した（メモリが利用可能になったため）

### 📊 **確定度のまとめ**

| 原因 | 確定度 | 根拠 |
|------|--------|------|
| Jiraテーブルの追加 | **95%** | 実装日とタイミングが一致、コード確認済み |
| minInstancesの増加 | **90%** | 設定ファイルで確認済み、ログで確認済み |
| メモリマップドファイル | **85%** | ログで異常な値が確認済み、ただしOSの実装に依存 |
| メモリ制限の増加 | **70%** | 設定ファイルで確認済み、ただし直接的な原因かは不確実 |

**総合確定度: 約90%**

上記の原因でメモリ使用量の急上昇が説明できます。ただし、メモリマップドファイルの共有の有無など、OSレベルの実装に依存する部分が約10%残っています。

**推奨される対策**:
1. **`minInstances: 1`に戻す**（メモリ使用量を約半分に削減）
2. **Jiraテーブルの初期化を遅延**（必要時のみ読み込む）✅ **実装済み**
3. **LanceDBのメモリマップドファイルの使用を最小化**（バッチ処理の実装済み）
4. **テーブルごとの初期化を最適化**（不要なテーブルは読み込まない）✅ **実装済み**

---

## 🚀 **複数テーブルの効率的な運用方法**

### 問題

たった2つのテーブル（confluence + jira_issues）でも、起動時に両方を初期化するとメモリ使用量が約2倍になります。

### 解決策：遅延初期化（Lazy Loading）

#### 1. **起動時は主要テーブルのみ初期化** ✅ **実装済み**

**変更内容**:
- 起動時には`confluence`テーブルのみ初期化
- `jira_issues`テーブルは検索リクエストが来た時にオンデマンドで初期化

**効果**:
- メモリ使用量を約半分に削減（約12GB → 約6GB）
- 起動時間の短縮
- 不要なテーブルを読み込まない

**コード箇所**: `src/lib/startup-optimizer.ts`

```typescript
// 主要テーブル（confluence）のみ起動時に初期化
const tablesToPreload = ['confluence'];
const tablesToLazyLoad = ['jira_issues']; // 遅延初期化

// 主要テーブルを優先的に初期化
for (const tableName of tablesToPreload) {
  await lunrInitializer.initializeAsync(tableName);
}

// 遅延初期化するテーブルは起動時には初期化しない
// 検索リクエストが来た時にオンデマンドで初期化される
```

#### 2. **オンデマンド初期化** ✅ **既に実装済み**

**実装箇所**: `src/lib/lancedb-search-client.ts`、`src/lib/hybrid-search-engine.ts`

- 検索リクエストが来た時に、必要なテーブルを初期化
- 初期化が完了するまで待機（最大180秒）
- 初期化中はベクトル検索のみで動作

#### 3. **優先順位付け**

**推奨される優先順位**:
1. **confluence**（主要テーブル、使用頻度が高い）
   - 起動時に初期化
   - 常にメモリに保持
2. **jira_issues**（補助テーブル、使用頻度が低い）
   - オンデマンドで初期化
   - 必要時のみメモリに保持

#### 4. **環境変数での制御（将来の拡張案）**

将来的には、環境変数でどのテーブルを起動時に初期化するか制御できるようにする：

```typescript
// 環境変数で制御（将来の拡張案）
const PRELOAD_TABLES = process.env.PRELOAD_TABLES?.split(',') || ['confluence'];
const LAZY_LOAD_TABLES = process.env.LAZY_LOAD_TABLES?.split(',') || ['jira_issues'];
```

### メモリ使用量の比較

| 初期化方法 | 起動時のメモリ使用量 | 備考 |
|-----------|-------------------|------|
| **両方のテーブルを起動時に初期化** | 約24GB | 現在の問題 |
| **主要テーブルのみ起動時に初期化** | 約12GB | ✅ **推奨** |
| **両方ともオンデマンド初期化** | 約0GB（起動時） | 初回検索が遅い |

### パフォーマンスへの影響

#### 起動時の初期化（confluenceのみ）
- **メモリ使用量**: 約12GB（約半分に削減）
- **起動時間**: 短縮（1テーブルのみ初期化）

#### オンデマンド初期化（jira_issues）
- **初回Jira検索**: 初期化時間がかかる（最大180秒）
- **2回目以降のJira検索**: 高速（既に初期化済み）
- **メモリ使用量**: 必要時のみ増加

### 実装済みの最適化

1. ✅ **バッチ処理でデータを取得**（メモリマップドファイルの使用を最小化）
2. ✅ **データベース接続を明示的に閉じる**（メモリを解放）
3. ✅ **主要テーブルのみ起動時に初期化**（メモリ使用量を削減）
4. ✅ **オンデマンド初期化**（不要なテーブルを読み込まない）

### 今後の改善案

1. **環境変数での制御**: どのテーブルを起動時に初期化するか設定可能にする
2. **使用頻度に基づく自動最適化**: 使用頻度の高いテーブルを優先的に初期化
3. **メモリ使用量の監視**: テーブルごとのメモリ使用量を監視し、不要なテーブルをアンロード

---

## 🔍 根本原因分析

### 1. Lunrインデックスのメモリ使用量 🔴 **最重要**

#### 問題
- **全ドキュメントをメモリに保持**: `lunr-search-client.ts`で全ドキュメント（最大10,000件）を`Map`に保持
- **Lunrインデックス自体**: インデックス構造もメモリに保持
- **ドキュメントデータ**: タイトル、コンテンツ、ラベルなどの全データをメモリに保持

#### コード箇所

```typescript
// src/lib/lunr-search-client.ts (213-224行目)
const tableDocuments = this.documents.get(tableName)!;
tableDocuments.clear();

// 全ドキュメントをMapに保持（メモリに常駐）
for (const doc of data.documents) {
  tableDocuments.set(doc.id, doc);
}
```

#### 推定メモリ使用量

| 項目 | 件数 | 1件あたりのサイズ | 合計 |
|------|------|------------------|------|
| ドキュメントデータ | 1,229件 | 約50KB（タイトル+コンテンツ+ラベル） | **約60MB** |
| Lunrインデックス | 1件 | 約200MB | **約200MB** |
| **合計（Lunr関連）** | - | - | **約260MB** |

### 2. LanceDBデータのメモリ読み込み 🟡 **重要**

#### 問題
- **初期化時の全データ読み込み**: `lunr-initializer.ts`で`limit(10000).toArray()`により全データをメモリに読み込む
- **ベクトルデータ**: 768次元 × 4バイト × 1,229件 = 約3.8MB（ベクトルのみ）
- **メタデータ**: タイトル、コンテンツ、ラベルなど = 約60MB

#### コード箇所

```typescript
// src/lib/lunr-initializer.ts (161行目)
const docs = await tbl.query().limit(10000).toArray();
```

#### 推定メモリ使用量

| 項目 | 件数 | 1件あたりのサイズ | 合計 |
|------|------|------------------|------|
| ベクトルデータ | 1,229件 | 約3KB（768次元 × 4バイト） | **約3.8MB** |
| メタデータ | 1,229件 | 約50KB | **約60MB** |
| **合計（LanceDB読み込み時）** | - | - | **約64MB** |

### 3. キャッシュのメモリ使用量 🟡 **重要**

#### 問題
- **検索結果キャッシュ**: `maxSize: 5000`エントリ
- **チャンクキャッシュ**: `maxCacheSize: 500MB`
- **埋め込みキャッシュ**: `maxSize: 1000`エントリ（サイズ制限なし）
- **回答キャッシュ**: `maxSize: 1000`エントリ

#### 推定メモリ使用量

| キャッシュ | 最大サイズ | 実際の使用量（推定） |
|-----------|-----------|-------------------|
| 検索結果キャッシュ | 5,000エントリ | 約50MB（1エントリ10KB想定） |
| チャンクキャッシュ | 500MB | **最大500MB** |
| 埋め込みキャッシュ | 1,000エントリ | 約3MB（1エントリ3KB想定） |
| 回答キャッシュ | 1,000エントリ | 約10MB（1エントリ10KB想定） |
| **合計（キャッシュ）** | - | **最大約563MB** |

### 4. その他のメモリ使用量 🟢 **通常範囲**

| 項目 | 推定サイズ |
|------|-----------|
| Node.jsランタイム | 約100MB |
| Next.jsフレームワーク | 約200MB |
| その他のライブラリ | 約100MB |
| **合計（その他）** | **約400MB** |

---

## 📊 合計メモリ使用量の推定

| カテゴリ | 推定サイズ |
|---------|-----------|
| Lunrインデックス + ドキュメント | 約260MB |
| LanceDBデータ読み込み時 | 約64MB |
| キャッシュ（最大） | 約563MB |
| その他（ランタイム等） | 約400MB |
| **合計（通常時）** | **約1,287MB** |
| **合計（キャッシュ最大時）** | **約1,787MB** |

**しかし、実際には8GBを超えているため、他の原因が考えられます。**

---

## 🚨 **実際のメモリ使用量（本番環境ログより）**

### 検索実行時のメモリ使用量

| 項目 | 値 | 備考 |
|------|-----|------|
| **heapUsed** | 123.22MB | ヒープ使用量（正常範囲） |
| **heapTotal** | 161.05MB | ヒープ総量（正常範囲） |
| **rss** | **7,696.05MB** | 実メモリ使用量（**異常に大きい**） |
| **external** | **12,523.84MB** | 外部メモリ（**異常に大きい**） |
| **arrayBuffers** | **12,511.72MB** | ArrayBuffer使用量（**異常に大きい**） |
| **total** | **25,158.78MB** | 合計（**約25GB！**） |

### 検索実行時のメモリ増加量

| 項目 | 増加量 | 備考 |
|------|--------|------|
| **heapUsed** | +4.74MB | 正常範囲 |
| **heapTotal** | +37.84MB | 正常範囲 |
| **rss** | **+7,406.17MB** | **異常に大きい** |
| **external** | **+12,519.79MB** | **異常に大きい** |
| **arrayBuffers** | **+12,511.34MB** | **異常に大きい** |

### 🔴 **根本原因の特定**

**`external`と`arrayBuffers`が12GB以上という異常な値は、LanceDBのデータがメモリに大量に読み込まれていることを示しています。**

#### 考えられる原因

1. **LanceDBのインデックスファイルがメモリに読み込まれている**
   - LanceDBはRustで書かれたネイティブライブラリ
   - データファイルをメモリマップドファイルとして読み込む可能性
   - これが`external`メモリとしてカウントされる

2. **`toArray()`呼び出しで全データがメモリに読み込まれている**
   - `vectorQuery.limit(90).toArray()`で90件のデータを取得
   - しかし、内部的に全データファイルがメモリに読み込まれている可能性

3. **複数のインスタンスが同時に起動している**
   - `minInstances: 1`に設定しているが、メモリ不足でクラッシュしたインスタンスが再起動
   - 複数のインスタンスが同時に存在する可能性

4. **LanceDBのデータファイルサイズが異常に大きい**
   - 通常のLanceDBデータファイルは数GB程度のはず
   - 12GBというのは異常に大きい

### 📊 **ログからの分析結果**

検索実行時のメモリ増加パターン：
- **検索開始時**: RSS 7.7GB、external 12.5GB、arrayBuffers 12.5GB
- **検索実行中**: RSS +7.4GB、external +12.5GB、arrayBuffers +12.5GB
- **合計**: 約25GB

**重要な観察**:
- `heapUsed`は正常範囲（123MB → 146MB）
- `external`と`arrayBuffers`が異常に大きい（12GB以上）
- これは**LanceDBのネイティブライブラリがメモリマップドファイルとしてデータを読み込んでいる**可能性が高い

### 🔍 **次の調査ステップ**

1. **LanceDBの`toArray()`呼び出し前後でメモリ監視を追加** ✅ 実装済み
2. **LanceDBのデータファイルサイズを確認**
3. **複数のインスタンスが同時に起動していないか確認**
4. **LanceDBのメモリマップドファイルの設定を確認**

---

## 🔧 **メモリマップドファイルを避ける方法**

### 問題

LanceDBのJavaScript APIでは、メモリマップドファイルを直接無効にするオプションは提供されていません。しかし、以下の対策を実装することで、メモリ使用量を削減できます。

### 実装済みの対策

#### 1. **バッチ処理でデータを取得** ✅

**Lunr初期化時の改善**:
- `limit(10000).toArray()`を小さなバッチ（500件ずつ）に分割
- `offset()`がサポートされている場合はバッチ処理を使用
- サポートされていない場合はフォールバックで全データを一度に取得

**コード箇所**: `src/lib/lunr-initializer.ts`

```typescript
// バッチ処理でデータを取得（メモリマップドファイルの使用を最小化）
const FETCH_BATCH_SIZE = 500;
let offset = 0;
while (hasMore) {
  const batchDocs = await tbl.query().limit(FETCH_BATCH_SIZE).offset(offset).toArray();
  // 処理...
  offset += batchDocs.length;
}
```

#### 2. **データベース接続を閉じてメモリを解放** ✅

**Lunr初期化時の改善**:
- データ取得後にデータベース接続を明示的に閉じる
- これにより、メモリマップドファイルの参照を解除

**コード箇所**: `src/lib/lunr-initializer.ts`

```typescript
// データベース接続を閉じてメモリを解放（メモリマップドファイルの参照を解除）
await db.close();
```

### 今後の対策案

#### 1. **プロジェクションを使用して必要なフィールドのみを取得**

```typescript
// 必要なフィールドのみを取得（メモリ使用量を削減）
const docs = await tbl.query()
  .select(['id', 'title', 'content', 'labels']) // 必要なフィールドのみ
  .limit(10000)
  .toArray();
```

#### 2. **ストリーミング処理（LanceDBがサポートしている場合）**

```typescript
// ストリーミングでデータを処理（メモリマップドファイルの使用を最小化）
const stream = await tbl.query().limit(10000).stream();
for await (const batch of stream) {
  // バッチごとに処理
}
```

#### 3. **データ取得後の明示的なメモリ解放**

```typescript
// データ処理後に変数をnullに設定してガベージコレクションを促す
let docs = await tbl.query().limit(10000).toArray();
// 処理...
docs = null; // 明示的にメモリを解放
```

### 制限事項

- **LanceDBのネイティブライブラリ**: Rustで書かれたネイティブライブラリがメモリマップドファイルを使用している場合、JavaScript側から直接制御することはできません
- **`toArray()`の動作**: `toArray()`は内部的に全データをメモリに読み込む可能性があります
- **接続の管理**: 接続を閉じても、メモリマップドファイルがすぐに解放されるとは限りません（OSのメモリ管理に依存）

### 公式ドキュメントの確認結果

[LanceDB公式ドキュメント](https://lancedb.com/docs/)を確認しましたが、メモリマップドファイルを無効化する直接的な設定やオプションは提供されていません。

**確認した内容**:
- Storage Options / Configuring Storage: ストレージ設定に関する情報はあるが、メモリマップドファイルの無効化オプションはなし
- Query Optimization: クエリ最適化の方法は記載されているが、メモリ使用量の直接的な制御はなし
- Performance: パフォーマンス最適化のガイドラインはあるが、メモリマップドファイルの制御はなし

**公式ドキュメントの推奨事項**:
- データのバッチ処理やストリーミング処理の導入
- メモリ使用量の監視と最適化
- クエリの最適化（必要なフィールドのみを取得するなど）

**結論**:
実装したバッチ処理アプローチは、公式ドキュメントの推奨事項と一致しています。メモリマップドファイルを直接無効化することはできませんが、バッチ処理によりメモリ使用量を削減できます。

---

## 🚨 考えられる追加の原因

### 1. **メモリリーク** 🔴 **最有力**

#### 可能性
- キャッシュが適切にクリアされていない
- イベントリスナーが適切に削除されていない
- クロージャーによる参照が保持されている

#### 確認方法
- メモリ使用量のログを追加
- キャッシュのサイズを定期的に監視

### 2. **複数のインスタンスが同時に起動** 🟡 **可能性あり**

#### ログから
```
Starting new instance. Reason: MANUAL_OR_CUSTOMER_MIN_INSTANCE
```

`minInstances: 1`に設定しているが、メモリ不足でクラッシュしたインスタンスが再起動し、複数のインスタンスが同時に存在する可能性があります。

### 3. **LanceDBのインデックスがメモリに読み込まれている** 🟡 **可能性あり**

#### 可能性
- ベクトルインデックス（IVF_PQ）がメモリに読み込まれている
- スカラーインデックス（page_id）がメモリに読み込まれている

#### 推定サイズ
- ベクトルインデックス: 約100-200MB
- スカラーインデックス: 約10-20MB

### 4. **Kuromoji辞書のメモリ使用量** 🟢 **通常範囲**

#### 推定サイズ
- Kuromoji辞書: 約50-100MB

---

## 🎯 推奨される対策

### 即座に実施すべき対策（優先度: ★★★ 高）

1. **メモリ使用量の監視ログを追加**
   - 各コンポーネントのメモリ使用量をログに記録
   - キャッシュのサイズを定期的に監視

2. **キャッシュサイズの削減**
   - チャンクキャッシュ: 500MB → 200MB
   - 検索結果キャッシュ: 5,000エントリ → 2,000エントリ

3. **Lunrインデックスの最適化**
   - ドキュメントデータをメモリに保持しない（必要時のみ取得）
   - インデックスのみをメモリに保持

### 中期的な対策（優先度: ★★☆ 中）

4. **メモリリークの調査**
   - メモリプロファイラーを使用
   - 定期的なガベージコレクション

5. **LanceDBの最適化**
   - インデックスのメモリ使用量を確認
   - 必要に応じてインデックスの最適化

### 長期的な対策（優先度: ★☆☆ 低）

6. **アーキテクチャの見直し**
   - Lunrインデックスを外部ストレージに保存
   - 必要時のみメモリに読み込む

---

## 📈 期待される改善効果

| 対策 | 現在 | 改善後 | 削減量 |
|------|------|--------|--------|
| キャッシュサイズ削減 | 563MB | 200MB | -363MB |
| Lunrインデックス最適化 | 260MB | 200MB | -60MB |
| **合計** | **823MB** | **400MB** | **-423MB** |

---

## 🔗 関連ドキュメント

- [パフォーマンス分析レポート](./PERFORMANCE_ANALYSIS_2025-11-21.md)
- [ハイブリッド検索システム仕様書](./02.01.02-hybrid-search-specification.md)
- [LanceDBデータ構造仕様書](./01.02.02-lancedb-data-structure-specification.md)

---

## 📝 実装メモ

### メモリ使用量の監視ログ追加

```typescript
// メモリ使用量をログに記録
function logMemoryUsage(label: string): void {
  const usage = process.memoryUsage();
  console.log(`[Memory] ${label}:`, {
    heapUsed: `${(usage.heapUsed / 1024 / 1024).toFixed(2)}MB`,
    heapTotal: `${(usage.heapTotal / 1024 / 1024).toFixed(2)}MB`,
    rss: `${(usage.rss / 1024 / 1024).toFixed(2)}MB`,
    external: `${(usage.external / 1024 / 1024).toFixed(2)}MB`
  });
}
```

### キャッシュサイズの削減

```typescript
// src/lib/lancedb-cache.ts
private readonly config = {
  maxCacheSize: 200 * 1024 * 1024, // 500MB → 200MB
  // ...
};

// src/lib/lancedb-search-client.ts
maxSize: 2000, // 5000 → 2000
```

---

## ✅ 次のステップ

1. メモリ使用量の監視ログを追加
2. キャッシュサイズを削減
3. Lunrインデックスの最適化を検討
4. メモリプロファイラーでメモリリークを調査

