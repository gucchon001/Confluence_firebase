# 本番アップロード同期の安全性検証

## 実施日
2025-01-28

## 質問

> Confluence、Jira両方とも安全な本番アップロード同期が可能になりましたか

## 回答

### ✅ はい、安全な本番アップロード同期が可能になりました

以下に詳細を説明します。

---

## 1. 安全性の確認項目

### 必要な要素

1. **テーブル分離**: ConfluenceとJiraのテーブルが互いに影響しない
2. **処理順序の保証**: インデックス作成→アップロードの順序が保証される
3. **確実な実行**: 全ての必要な処理が確実に実行される
4. **エラーハンドリング**: エラー時に適切に処理される

---

## 2. Confluence完全再構築スクリプト

**ファイル**: `scripts/sync-confluence-full-rebuild.ts`  
**npmコマンド**: `npm run sync:confluence:rebuild`

### 処理フロー

```bash
1. Confluenceデータ同期（Firestore + LanceDB）
   ↓
2. StructuredLabel同期（Firestore → LanceDB）
   ↓
3. Lunrインデックスの再構築
   ↓
4. LanceDBインデックスの作成
   ↓
5. GCSへのアップロード（Confluenceテーブルのみ）
```

### ✅ 安全性の確認

| 項目 | 状態 | 詳細 |
|-----|------|------|
| **テーブル分離** | ✅ | `UPLOAD_TABLE_FILTER=confluence`でConfluenceテーブルのみ |
| **インデックス作成** | ✅ | アップロード前に確実に実行（Step 4） |
| **処理順序** | ✅ | 正しい順序で実行（Step 1→2→3→4→5） |
| **エラーハンドリング** | ✅ | StructuredLabel同期は失敗しても継続 |
| **Lunrキャッシュ** | ✅ | Confluence用キャッシュのみ（テーブルフィルター対応） |

---

## 3. Jira完全再構築スクリプト

**ファイル**: `scripts/sync-jira-full-rebuild.ts`  
**npmコマンド**: `npm run sync:jira:rebuild`

### 処理フロー

```bash
1. Jiraデータ同期（Firestore + LanceDB）
   ↓
2. StructuredLabel同期（Firestore → LanceDB）
   ↓
3. Lunrインデックスの初期化
   ↓
4. LanceDBインデックスの作成
   ↓
5. GCSへのアップロード（Jiraテーブルのみ）
```

### ✅ 安全性の確認

| 項目 | 状態 | 詳細 |
|-----|------|------|
| **テーブル分離** | ✅ | `UPLOAD_TABLE_FILTER=jira_issues`でJiraテーブルのみ |
| **インデックス作成** | ✅ | アップロード前に確実に実行（Step 4） |
| **処理順序** | ✅ | 正しい順序で実行（Step 1→2→3→4→5） |
| **エラーハンドリング** | ✅ | StructuredLabel同期は失敗しても継続 |
| **Lunrキャッシュ** | ✅ | Jira用キャッシュのみ（テーブルフィルター対応） |

---

## 4. 安全性の詳細検証

### 4.1 テーブル分離の確認

#### Confluence完全再構築スクリプト

```typescript
// Step 5: GCSアップロード時
const { stdout, stderr } = await execAsync('npx tsx scripts/upload-production-data.ts', {
  env: {
    ...process.env,
    UPLOAD_TABLE_FILTER: 'confluence'  // ✅ Confluenceテーブルのみ
  }
});
```

#### Jira完全再構築スクリプト

```typescript
// Step 5: GCSアップロード時
const { stdout, stderr } = await execAsync('npx tsx scripts/upload-production-data.ts', {
  env: {
    ...process.env,
    UPLOAD_TABLE_FILTER: 'jira_issues'  // ✅ Jiraテーブルのみ
  }
});
```

#### upload-production-data.tsの実装

```typescript
// テーブルフィルター（環境変数で指定可能）
const tableFilter = process.env.UPLOAD_TABLE_FILTER;
if (tableFilter) {
  const originalCount = tableNames.length;
  tableNames = tableNames.filter(name => name === tableFilter);
  // ✅ フィルターに一致するテーブルのみがアップロードされる
}
```

**✅ テーブル分離が確実に実現される**

### 4.2 インデックス作成の確認

#### 処理順序

1. **データ同期** → LanceDBテーブルにデータを保存
2. **StructuredLabel同期** → LanceDBテーブルを更新
3. **Lunrインデックス** → キーワード検索用インデックスを構築
4. **LanceDBインデックス** → ベクトル検索用インデックスを作成
5. **GCSアップロード** → インデックス含むテーブルをアップロード

**✅ インデックス作成がアップロード前に確実に実行される**

### 4.3 Lunrキャッシュの分離

#### upload-production-data.tsの実装

```typescript
// Lunrキャッシュをアップロード（テーブルフィルターが指定されている場合は該当キャッシュのみ）
const tableFilter = process.env.UPLOAD_TABLE_FILTER;
const cacheCount = await uploadLunrCache(bucket, tableFilter);

// uploadLunrCache関数内
if (tableFilter) {
  if (tableFilter === 'jira_issues') {
    cacheFiles = cacheFiles.filter(file => file.includes('jira_issues'));
  } else if (tableFilter === 'confluence') {
    cacheFiles = cacheFiles.filter(file => file.includes('confluence') || !file.includes('jira_issues'));
  }
}
```

**✅ テーブルフィルターに対応したキャッシュのみがアップロードされる**

---

## 5. 安全性のまとめ

### ✅ Confluence

- ✅ **テーブル分離**: Confluenceテーブルのみがアップロードされる
- ✅ **インデックス作成**: アップロード前に確実に実行
- ✅ **処理順序**: 正しい順序で実行
- ✅ **エラーハンドリング**: 適切に処理される
- ✅ **Lunrキャッシュ**: Confluence用キャッシュのみ

### ✅ Jira

- ✅ **テーブル分離**: Jiraテーブルのみがアップロードされる
- ✅ **インデックス作成**: アップロード前に確実に実行
- ✅ **処理順序**: 正しい順序で実行
- ✅ **エラーハンドリング**: 適切に処理される
- ✅ **Lunrキャッシュ**: Jira用キャッシュのみ

---

## 6. 結論

### ✅ 安全な本番アップロード同期が可能

ConfluenceとJiraの両方について、以下が実現されています：

1. **✅ テーブル分離**: 互いに影響を与えない
2. **✅ インデックス作成**: アップロード前に確実に実行
3. **✅ 処理順序の保証**: 正しい順序で実行
4. **✅ エラーハンドリング**: 適切に処理される
5. **✅ 完全再構築スクリプト**: 全ての処理が一括で実行

### 使用方法

```bash
# Confluence完全再構築
npm run sync:confluence:rebuild

# Jira完全再構築
npm run sync:jira:rebuild
```

これで、安全に本番環境にアップロードできます。
