# 検索パフォーマンス詳細分析 (2025-11-22)

**作成日**: 2025年11月22日  
**ステータス**: 🔍 分析中

---

## 📊 問題の症状

### テスト結果サマリー

| クエリ | 検索時間 | メモリ差分（RSS） | 評価 |
|--------|---------|------------------|------|
| 1. 学年自動更新バッチ | **908ms** | -3.51MB | ✅ **正常** |
| 2. 教室管理の詳細 | **46091ms** (約46秒) | +1.04MB | ❌ **異常** |
| 3. 会員登録機能 | **34055ms** (約34秒) | +0.50MB | ❌ **異常** |
| 4. 求人削除機能 | **24050ms** (約24秒) | -1.03MB | ❌ **異常** |
| 5. 応募管理の一覧 | **55694ms** (約56秒) | -2.95MB | ❌ **異常** |

**問題**: クエリ2-5の検索時間が24-56秒と異常に長い（目標: 2000ms以下）

---

## 🔍 原因分析

### 原因候補1: **Lunrインデックスの再読み込み** 🔴 **最有力**

**証拠**:
1. **クエリ1が正常（908ms）**: ウォームアップリクエスト後の最初のクエリが正常
2. **クエリ2-5が異常に遅い（24-56秒）**: キャッシュクリア後のウォームアップ後に異常
3. **ウォームアップリクエストの時間**:
   - クエリ1の前: 77442ms（約77秒）⚠️ **異常に長い**（初回のLunrインデックス読み込み）
   - クエリ2-5の前: 371-865ms ✅ **正常**（しかし、実際のテストクエリで検索が遅い）

**仮説**: 
- ウォームアップリクエストが完了したと思っているが、Lunrインデックスの再読み込みがバックグラウンドで継続している
- 5秒の待機時間が不十分で、Lunrインデックスの再読み込みが完了していない状態でテストクエリが実行される

---

### 原因候補2: **ベクトル検索の遅延** 🟡 **中程度**

**可能性**:
- LanceDBのメモリマップドファイルの読み込みに時間がかかっている
- ベクトル検索のクエリ実行に時間がかかっている

**確認方法**:
- サーバー側のログで`[PERF] 🔍 Vector search completed`の時間を確認
- ベクトル検索が5秒以上かかっている場合、これが原因

---

### 原因候補3: **BM25検索の遅延** 🟡 **中程度**

**可能性**:
- BM25検索の初期化待機時間が長い
- キーワード検索の実行に時間がかかっている

**確認方法**:
- サーバー側のログで`[BM25 Search] ✅ BM25 search completed`の時間を確認
- BM25検索が5秒以上かかっている場合、これが原因

---

## 📋 調査方法

### ステップ1: サーバー側のログを確認

開発サーバーのターミナルで以下のログを確認：

```bash
# 検索処理の開始
[PERF] 🔍 検索処理開始（ユーザー認識時間）: <timestamp>

# retrieveRelevantDocsの呼び出し
[PERF] 📥 retrieveRelevantDocs呼び出し開始: <time>ms (リクエスト受信からの経過時間)
[PERF] 📥 retrieveRelevantDocs完了: <time>ms (累計: <time>ms)

# 実際の検索処理開始
[PERF] 🔍 実際の検索処理開始: <time>ms (初期化時間を除外)

# 並列検索の完了
[PERF] ⏱️ Phase 5 parallel search completed in <time>ms (<time>s)

# ベクトル検索の完了
[PERF] 🔍 Vector search completed in <time>ms

# BM25検索の完了
[BM25 Search] ✅ BM25 search completed in <time>ms

# BM25初期化待機時間
[BM25 Search] ✅ Lunr ready for <table> after <time>ms total wait time

# 検索処理の完了
[PERF] 🔍 検索処理完了（ユーザー認識時間）: 総時間 <time>ms (リクエスト受信から検索完了まで)
```

---

### ステップ2: 時間の内訳を分析

各クエリで以下の時間を測定：

1. **retrieveRelevantDocsの時間**
   - サーバー側のログ: `[PERF] 📥 retrieveRelevantDocs完了: <time>ms`
   - 目標: 5000ms以下

2. **ベクトル検索の時間**
   - サーバー側のログ: `[PERF] 🔍 Vector search completed in <time>ms`
   - 目標: 1000ms以下

3. **BM25検索の時間**
   - サーバー側のログ: `[BM25 Search] ✅ BM25 search completed in <time>ms`
   - 目標: 2000ms以下

4. **BM25初期化待機時間**
   - サーバー側のログ: `[BM25 Search] ✅ Lunr ready for <table> after <time>ms total wait time`
   - 目標: 5000ms以下

5. **その他の処理時間**
   - RRF融合、スコアリング、フィルタリングなど
   - 目標: 1000ms以下

---

### ステップ3: ボトルネックを特定

**検索時間の内訳**:
```
検索時間 = retrieveRelevantDocs時間 + その他の処理時間
         = (ベクトル検索時間 + BM25検索時間 + enrichWithAllChunks時間 + filterInvalidPages時間) + その他の処理時間
```

**ボトルネックの特定**:
- 検索時間が24-56秒の場合、どの段階で時間がかかっているか確認
- 最も時間がかかっている段階がボトルネック

---

## 🎯 推奨事項

### 対策1: **ウォームアップリクエストの完了を確実に待つ** 🔴 **最優先**

**現在の実装**:
- ウォームアップリクエスト完了後、5秒待機
- しかし、Lunrインデックスの再読み込みには10-40秒かかる可能性がある

**改善案**:
1. **Lunrインデックスの初期化完了をポーリングで確認**
   ```typescript
   // Lunrインデックスの初期化完了を確認
   while (!lunrSearchClient.isReady(tableName)) {
     await new Promise(resolve => setTimeout(resolve, 100));
   }
   ```

2. **待機時間を動的に調整**
   ```typescript
   // ウォームアップリクエストの実行時間に応じて待機時間を調整
   const warmupDuration = warmupEndTime - warmupStartTime;
   const waitTime = Math.max(5000, warmupDuration * 1.5); // ウォームアップ時間の1.5倍、最低5秒
   await new Promise(resolve => setTimeout(resolve, waitTime));
   ```

3. **初期化完了の確認**
   ```typescript
   // 初期化完了をポーリングで確認（最大60秒）
   const maxWaitTime = 60000;
   const pollingInterval = 500;
   const startTime = Date.now();
   while (!lunrSearchClient.isReady(tableName) && (Date.now() - startTime) < maxWaitTime) {
     await new Promise(resolve => setTimeout(resolve, pollingInterval));
   }
   ```

---

### 対策2: **キャッシュクリアの見直し** 🟡 **中優先度**

**現在の実装**:
- 各クエリの前にキャッシュをクリア
- Lunrインデックスがメモリから削除される

**改善案**:
1. **テスト開始前に1回だけクリア**
   - 各クエリの前にクリアするのではなく、テスト開始前に1回だけクリア
   - これにより、Lunrインデックスの再読み込みが1回だけになる

2. **キャッシュクリアをスキップ**
   - ウォームアップリクエストのみ実行し、キャッシュクリアをスキップ
   - これにより、Lunrインデックスの再読み込みが不要になる

---

### 対策3: **サーバー側のログ出力を強化** 🟡 **中優先度**

**現在の実装**:
- サーバー側のログは詳細だが、クライアント側から直接取得できない

**改善案**:
1. **パフォーマンス情報をクライアントに送信**
   - `step_update`メッセージに`performance`フィールドを追加
   - ベクトル検索時間、BM25検索時間、初期化待機時間などを含める

2. **ログファイルに出力**
   - パフォーマンス情報をログファイルに出力
   - テストスクリプトでログファイルを読み込んで分析

---

## 📊 調査結果の記録

サーバー側のログを確認したら、以下の情報を記録：

1. **各クエリの検索時間の内訳**:
   - retrieveRelevantDocs時間
   - ベクトル検索時間
   - BM25検索時間
   - BM25初期化待機時間
   - その他の処理時間

2. **ボトルネックの特定**:
   - どの段階で時間がかかっているか
   - 時間がかかっている理由（Lunrインデックスの再読み込み、ベクトル検索の遅延、BM25検索の遅延など）

3. **改善効果の確認**:
   - 対策実施後の検索時間
   - 各段階の時間の変化

---

## 🔗 関連ドキュメント

- [メモリ監視付きパフォーマンステスト結果](./05.39-memory-monitoring-test-results-2025-11-22.md)
- [コールドスタート発生原因の分析](./05.36-cold-start-analysis-2025-11-22.md)
- [パフォーマンスデグレード分析](./05.38-performance-regression-analysis-2025-11-22.md)
- [Lunrインデックス初期化](../01-architecture/02.01.02-hybrid-search-specification.md)

