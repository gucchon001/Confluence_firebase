# クエリ3 パフォーマンス改善計画 (2025-11-22)

**作成日**: 2025年11月22日  
**目的**: 検索時間を2436msから2000ms以下に削減  
**ステータス**: 📋 **改善計画策定中**

---

## 📊 現状分析

### 検索処理の時間内訳

| 段階 | 時間 | 評価 |
|------|------|------|
| ベクトル検索 | **198ms** | ✅ **正常** |
| BM25検索 | **473ms** | ✅ **正常** |
| 並列検索完了 | **475ms** | ✅ **正常** |
| **その他（RRF、スコアリングなど）** | **約1232ms** | ⚠️ **ボトルネック** |
| searchLanceDB完了 | **1707ms** | ⚠️ **やや長い** |
| 検索処理完了 | **2436ms** | ⚠️ **目標超過（約22%）** |

---

## 🎯 改善目標

### 目標値

- **検索処理完了**: 2436ms → **2000ms以下**（約18%削減）
- **その他処理**: 1232ms → **700ms以下**（約43%削減）

---

## 🔍 ボトルネック分析

### ボトルネック1: **RRF融合処理** 🔴 **最優先**

**現在の実装**:
- `unifiedSearchResultProcessor.processSearchResults()` で実行
- 全結果に対してRRFスコアを計算
- 複数のソート処理（byVector, byKeyword, byTitleExact, byBm25）

**推定時間**: 約300-500ms

**改善案**:
1. **早期絞り込み**: RRF計算前に結果数を制限（例: 200件 → 100件）
2. **並列ソート**: 複数のソート処理を並列化
3. **キャッシュ**: 頻繁に検索されるクエリのRRFスコアをキャッシュ

---

### ボトルネック2: **Composite Scoring処理** 🔴 **最優先**

**現在の実装**:
- 上位100件に対してComposite Scoringを実行
- `compositeScoringService.scoreAndRankResults()` で実行
- 各結果に対してラベルスコア、タイトルスコアなどを計算

**推定時間**: 約400-600ms

**改善案**:
1. **結果数の削減**: 上位100件 → 上位50件に削減
2. **並列処理**: 複数の結果のスコア計算を並列化
3. **早期終了**: スコアが低い結果は早期に除外

---

### ボトルネック3: **タイトル救済検索** 🟡 **中優先度**

**現在の実装**:
- タイトル候補を最大10件検索
- 各タイトルに対してLunr検索 + LanceDBクエリを実行
- 並列実行されているが、LanceDBクエリが重い

**推定時間**: 約200-300ms

**改善案**:
1. **タイトル候補数の削減**: 10件 → 5件に削減
2. **バッチクエリの最適化**: 複数のpage_idを一度に取得（既に実装済み）
3. **キャッシュ**: タイトル検索結果をキャッシュ

---

### ボトルネック4: **BM25結果のマージ処理** 🟡 **中優先度**

**現在の実装**:
- BM25結果に対して `calculateKeywordScore` を実行
- 各結果に対してキーワードスコアを計算

**推定時間**: 約100-200ms

**改善案**:
1. **バッチ処理**: 複数の結果のキーワードスコアを一度に計算
2. **早期終了**: スコアが低い結果は早期に除外

---

### ボトルネック5: **重複除去処理** 🟢 **低優先度**

**現在の実装**:
- 同一pageId/titleの重複を1件に正規化
- Mapを使用した重複除去

**推定時間**: 約50-100ms

**改善案**:
1. **早期重複除去**: RRF計算前に重複を除去
2. **最適化**: Mapの操作を最適化

---

## 📋 ステップバイステップ改善計画

### ステップ1: **Composite Scoringの結果数を削減** 🔴 **最優先**

**目標**: 約400-600ms → 約200-300ms（約50%削減）

**実装内容**:
- 上位100件 → 上位50件に削減
- 残りの結果は簡易スコア（RRFスコアの50%）を使用

**期待効果**: 約200-300ms削減

**実装場所**: `src/lib/lancedb-search-client.ts` (848行目)

```typescript
// 現在: 上位100件
const TOP_N_FOR_COMPOSITE = 100;

// 改善後: 上位50件
const TOP_N_FOR_COMPOSITE = 50;
```

---

### ステップ2: **RRF融合処理の早期絞り込み** 🔴 **最優先**

**目標**: 約300-500ms → 約150-250ms（約50%削減）

**実装内容**:
- RRF計算前に結果数を制限（例: 200件 → 100件）
- 並列ソート処理の最適化

**期待効果**: 約150-250ms削減

**実装場所**: `src/lib/lancedb-search-client.ts` (747行目付近)

```typescript
// 現在: 全結果に対してRRF計算
const rrfProcessedResults = unifiedSearchResultProcessor.processSearchResults(resultsWithHybridScore, {...});

// 改善後: 早期絞り込み
const topCandidates = resultsWithHybridScore.slice(0, 100); // 上位100件のみ
const rrfProcessedResults = unifiedSearchResultProcessor.processSearchResults(topCandidates, {...});
```

---

### ステップ3: **タイトル救済検索の候補数を削減** 🟡 **中優先度**

**目標**: 約200-300ms → 約100-150ms（約50%削減）

**実装内容**:
- タイトル候補数を10件 → 5件に削減

**期待効果**: 約100-150ms削減

**実装場所**: `src/lib/lancedb-search-client.ts` (454行目)

```typescript
// 現在: 最大10件
titles = titles.slice(0, 10);

// 改善後: 最大5件
titles = titles.slice(0, 5);
```

---

### ステップ4: **BM25結果のマージ処理の最適化** 🟡 **中優先度**

**目標**: 約100-200ms → 約50-100ms（約50%削減）

**実装内容**:
- バッチ処理: 複数の結果のキーワードスコアを一度に計算
- 早期終了: スコアが低い結果は早期に除外

**期待効果**: 約50-100ms削減

**実装場所**: `src/lib/lancedb-search-client.ts` (692-740行目)

---

### ステップ5: **重複除去処理の最適化** 🟢 **低優先度**

**目標**: 約50-100ms → 約25-50ms（約50%削減）

**実装内容**:
- 早期重複除去: RRF計算前に重複を除去
- Mapの操作を最適化

**期待効果**: 約25-50ms削減

**実装場所**: `src/lib/lancedb-search-client.ts` (768-780行目)

---

## 📊 期待効果の合計

| 改善項目 | 現在 | 改善後 | 削減時間 |
|---------|------|--------|---------|
| Composite Scoring | 400-600ms | 200-300ms | **200-300ms** |
| RRF融合処理 | 300-500ms | 150-250ms | **150-250ms** |
| タイトル救済検索 | 200-300ms | 100-150ms | **100-150ms** |
| BM25結果のマージ | 100-200ms | 50-100ms | **50-100ms** |
| 重複除去処理 | 50-100ms | 25-50ms | **25-50ms** |
| **合計** | **1050-1700ms** | **525-850ms** | **約525-850ms削減** |

**期待される検索処理完了時間**: 2436ms → **約1586-1911ms**（目標: 2000ms以下）✅

---

## 🔧 実装順序

### ⚠️ 品質テストの実施

**各改善案を実装する前に、必ず品質テストを実行して合格基準を満たすことを確認してください。**

### Phase 1: **即効性の高い改善**（ステップ1-2）

1. Composite Scoringの結果数を削減（100件 → 50件）
   - **品質テスト**: 実装後に品質テストを実行し、合格基準を満たすことを確認
2. RRF融合処理の早期絞り込み（200件 → 100件）
   - **品質テスト**: 実装後に品質テストを実行し、合格基準を満たすことを確認

**期待効果**: 約350-550ms削減

**注意**: 品質テストに不合格の場合は、改善案を見直すか、パラメータを調整する必要があります。

---

### Phase 2: **追加の改善**（ステップ3-4）

3. タイトル救済検索の候補数を削減（10件 → 5件）
   - **品質テスト**: 実装後に品質テストを実行し、合格基準を満たすことを確認
4. BM25結果のマージ処理の最適化
   - **品質テスト**: 実装後に品質テストを実行し、合格基準を満たすことを確認

**期待効果**: 約150-250ms削減

**注意**: 品質テストに不合格の場合は、改善案を見直すか、パラメータを調整する必要があります。

---

### Phase 3: **微調整**（ステップ5）

5. 重複除去処理の最適化
   - **品質テスト**: 実装後に品質テストを実行し、合格基準を満たすことを確認

**期待効果**: 約25-50ms削減

**注意**: 品質テストに不合格の場合は、改善案を見直すか、パラメータを調整する必要があります。

---

## ✅ 実装後の検証

### 検証項目

1. **検索処理完了時間**: 2000ms以下を達成
2. **検索精度**: 改善前と同等または向上（**品質テスト基準を満たすこと**）
3. **メモリ使用量**: 増加しないこと

### 品質テスト基準

**必須条件**: 以下のクエリで検索を実行した際、検索結果の10位以内に指定されたページが含まれること

- **クエリ**: `退会した会員が同じアドレス使ったらどんな表示がでますか`
- **対象ページ**: `045_【FIX】パスワード再設定機能`
- **合格基準**: 対象ページが10位以内に含まれること

### 検証方法

1. **品質テストを実行**:
   ```bash
   npm run test:search-quality -- --query="退会した会員が同じアドレス使ったらどんな表示がでますか" --target="045_【FIX】パスワード再設定機能"
   ```

2. **パフォーマンステストを実行**:
   - クエリ3を再実行
   - サーバー側のログを確認
   - 各段階での処理時間を測定

3. **結果の確認**:
   - 品質テストが合格することを確認
   - 検索処理完了時間が2000ms以下であることを確認

---

## 🔗 関連ドキュメント

- [クエリ3 詳細分析](./05.47-query3-detailed-analysis-2025-11-22.md)
- [サーバー側ログ分析ガイド](./05.41-server-log-analysis-guide-2025-11-22.md)

