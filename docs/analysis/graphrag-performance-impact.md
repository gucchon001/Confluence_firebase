# GraphRAG導入のパフォーマンス影響分析

## 実行日
2025年10月19日

---

## 1. グラフトラバーサルのコスト

### 現在の1-hop参照（無効化済み）
```
ページA → ページB（1件取得）
処理時間: 約9.2秒（30ページ × 平均0.3秒）
```

### 本格的GraphRAGの2-3 hop探索
```
ページA → ページB → ページC → ページD
   ↓         ↓         ↓
  関連1    関連2    関連3
  関連2    関連3    関連4
  
計算量: O(n^hop) ※nは平均エッジ数
- 1-hop: 30ページ × 2エッジ = 60クエリ
- 2-hop: 30 × 2 × 2 = 120クエリ
- 3-hop: 30 × 2 × 2 × 2 = 240クエリ
```

**予測時間:**
- 1-hop: 9.2秒（実測値）
- 2-hop: **18-25秒**
- 3-hop: **35-50秒**

---

## 2. Community Detection（コミュニティ検出）

### アルゴリズム
- Louvain法
- Label Propagation
- Girvan-Newman

### 計算量
```
O(m × log(n))
※ m=エッジ数（24,208）、n=ノード数（679）
```

**予測時間:**
- 初回計算: **5-10秒**
- キャッシュあり: 0.1秒

---

## 3. サブグラフ抽出

### 処理内容
```typescript
// 関連ノードの収集
for (const node of relevantNodes) {
  const neighbors = getNeighbors(node, 2); // 2-hop
  const subgraph = extractSubgraph(neighbors);
  // → Firestoreクエリが大量発生
}
```

**予測時間:**
- 10ノード × 2-hop: **3-5秒**
- 30ノード × 2-hop: **10-15秒**

---

## 4. パス解析（最短パス・重要パス）

### アルゴリズム
- Dijkstra法
- A*探索
- PageRank

**予測時間:**
- 10パス計算: **2-3秒**
- 30パス計算: **5-8秒**

---

## 5. Firestoreクエリのボトルネック

### 現在の実装（1-hop）
```
- バッチクエリ: 30ページ → 1回のクエリ
- エッジ取得: 790エッジ
- ノード取得: 60ノード
- 合計: 約9.2秒
```

### GraphRAG（3-hop）
```
- 初回クエリ: 30ページ
- 2-hop: 30 × 2 = 60クエリ
- 3-hop: 60 × 2 = 120クエリ
- エッジ取得: 数千件
- ノード取得: 数百件
- 合計: **30-50秒**
```

---

## 6. 最適化後の予測

### キャッシュ戦略
```typescript
// グラフ構造をメモリキャッシュ
const graphCache = new Map<string, Subgraph>();

// Community Detection結果をキャッシュ
const communityCache = new Map<string, Community[]>();
```

**最適化後の予測時間:**
- 初回検索: 25-35秒
- キャッシュヒット: **5-10秒**

---

## 7. パフォーマンス比較表

| 実装方式 | 初回検索 | 2回目以降 | メモリ使用量 | 複雑度 |
|----------|---------|----------|-------------|--------|
| **現在（KG無効化）** | 0.82秒 | 0.82秒 | 低 | 低 |
| **1-hop参照** | 10秒 | 10秒 | 低 | 低 |
| **GraphRAG（最適化なし）** | 30-50秒 | 30-50秒 | 高 | 高 |
| **GraphRAG（最適化あり）** | 25-35秒 | 5-10秒 | 非常に高 | 高 |

---

## 8. 品質向上の期待値

### GraphRAGの強み
1. **複雑な質問への対応**
   - 「AからBまでの手順」
   - 「AとBの関係」
   - 「Aに関連するすべての機能」

2. **文脈理解の向上**
   - グラフ構造から暗黙の関係を抽出
   - 複数ページにまたがる知識の統合

### 現在の実装で対応できているケース
- 単純な機能検索: ✅ 発見率100%
- 機能詳細の取得: ✅ 発見率100%
- 操作手順の確認: ✅ 発見率100%

### GraphRAGが必要になるケース
- ❓ 現時点では該当なし
- ❓ ユーザーからの要望もなし

---

## 9. 結論

### パフォーマンス影響
- **初回検索: 0.82秒 → 25-35秒**（**30-40倍遅い**）
- **キャッシュ後: 0.82秒 → 5-10秒**（**6-12倍遅い**）

### 推奨判断

#### ❌ GraphRAG導入を推奨しない理由
1. **パフォーマンス大幅悪化**
   - ユーザー体験の著しい低下
   - 30秒の待ち時間は許容できない

2. **品質向上の必要性が不明**
   - 現在の発見率: 100%
   - GraphRAGで解決する問題が存在しない

3. **実装・運用コスト**
   - 開発工数: 2-4週間
   - メモリ使用量: 大幅増加
   - 保守コスト: 高い

#### ✅ 現状維持を推奨
- パフォーマンス: 0.82秒（優秀）
- 品質: 発見率100%（十分）
- シンプルで保守しやすい

---

## 10. 将来的な検討条件

以下の条件が満たされた場合のみ、GraphRAG導入を再検討:

1. **品質問題の発生**
   - 発見率が90%未満に低下
   - 複雑な関係性の質問が増加

2. **パフォーマンス改善策の確立**
   - グラフデータベース（Neo4j等）の導入
   - 事前計算・キャッシュ戦略の確立
   - 検索時間を5秒以内に抑制可能

3. **ユーザー要望**
   - 複雑な関係性検索の明確なニーズ
   - パフォーマンス犠牲の許容

---

## 参考資料

- [ナレッジグラフを活用するGraphRAGを俯瞰する](https://zenn.dev/zenkigen_tech/articles/0a25b2eaefb304)
- Graph Retrieval-Augmented Generation: A Survey (arXiv:2408.08921)

