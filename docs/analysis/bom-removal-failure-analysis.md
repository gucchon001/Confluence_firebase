# BOM除去ができていない可能性のある要因分析

**作成日**: 2025-11-07  
**最終更新**: 2025-11-07  
**目的**: BOM除去処理が正しく機能していない可能性のある要因を分析

## エラー状況

本番環境で以下のエラーが発生：
```
TypeError: Cannot convert argument to a ByteString because the character at index 0 has a value of 65279 which is greater than 255.
```

BOM除去処理は実装されているが、エラーが発生している。

## 重要な前提条件

- ✅ **ローカル環境では正常に動作している**
- ✅ **データベースはローカル環境のものをアップロードしている**
- ❌ **本番環境でのみエラーが発生**

この前提条件から、**データベース自体にBOMが含まれている可能性は低い**。本番環境特有の問題に焦点を当てる必要がある。

## 考えられる要因

### 1. **キャッシュキーの問題（最も可能性が高い）**

**問題点**:
- `getEmbeddings`関数で、キャッシュキーは`text.substring(0, 100)`を使用
- BOM除去処理はキャッシュチェックの**後**に実行される
- しかし、キャッシュキーはBOM除去**前**のテキストを使用している

**影響**:
- BOMを含むテキストとBOMを含まないテキストで異なるキャッシュキーが生成される
- キャッシュから取得した場合はBOM除去処理をスキップするが、キャッシュに保存する際にBOM除去後のテキストを使用している
- ただし、キャッシュから取得する場合はBOM除去処理をスキップしているため、問題ないはず

**確認方法**:
- キャッシュキーの生成タイミングを確認
- BOM除去前と後のテキストでキャッシュキーが異なることを確認

### 2. **BOM除去処理のタイミングの問題**

**問題点**:
- `getEmbeddings`関数でBOM除去処理を実行
- その後、`getGeminiEmbeddings`関数でもBOM除去処理を実行
- しかし、`getGeminiEmbeddings`関数に渡されるテキストにBOMが含まれている可能性

**影響**:
- BOM除去処理が正しく機能していない可能性
- または、BOM除去処理の後にBOMが再び追加されている可能性

**確認方法**:
- `getGeminiEmbeddings`関数に渡されるテキストにBOMが含まれているか確認
- BOM除去処理の前後でテキストを比較

### 3. **文字列のエンコーディングの問題**

**問題点**:
- JavaScriptの文字列はUTF-16でエンコードされている
- BOM文字（\uFEFF）はUTF-16の文字として扱われる
- しかし、`replace(/\uFEFF/g, '')`が正しく機能していない可能性

**影響**:
- BOM除去処理が正しく機能していない可能性
- または、BOM文字が別の形式でエンコードされている可能性

**確認方法**:
- BOM文字の文字コードを確認（65279 = 0xFEFF）
- `replace(/\uFEFF/g, '')`が正しく機能しているか確認

### 4. **サロゲートペアの問題**

**問題点**:
- JavaScriptの文字列はUTF-16でエンコードされている
- サロゲートペア（2つの16ビット値で1つの文字を表現）の場合、`charCodeAt(0)`が正しく機能しない可能性

**影響**:
- BOM文字の検出が正しく機能していない可能性
- ただし、BOM文字（\uFEFF）はサロゲートペアではないため、この問題は発生しないはず

**確認方法**:
- BOM文字の文字コードを確認（65279 = 0xFEFF）
- `charCodeAt(0)`が正しく機能しているか確認

### 5. **HTTPリクエストボディのエンコーディング処理（本番環境特有・最も可能性が高い）**

**問題点**:
- 本番環境では、HTTPリクエストボディがUTF-8でエンコードされているが、BOMが含まれている可能性がある
- `req.json()`でパースする際に、BOMが含まれている可能性がある
- ローカル環境では発生しないが、本番環境（Cloud Run）では発生する可能性がある

**影響**:
- HTTPリクエストボディから取得した`question`にBOMが含まれている可能性
- `src/app/api/streaming-process/route.ts`でBOM除去処理を実行しているが、実行される前にBOMが含まれている可能性
- または、BOM除去処理の後にBOMが再び追加されている可能性

**確認方法**:
- 本番環境のログで`[BOM DETECTED]`を検索して、HTTPリクエストボディにBOMが含まれているか確認
- `req.json()`でパースする前後でBOMをチェック
- HTTPリクエストヘッダーの`Content-Type`や`Content-Encoding`を確認

**修正方法**:
- `req.json()`でパースする前に、リクエストボディを文字列として取得してBOMを除去
- または、`req.json()`でパースした後、すべての文字列フィールドからBOMを除去

### 6. **キャッシュの問題（本番環境特有）**

**問題点**:
- 本番環境では、複数のインスタンスが動作している可能性がある
- 各インスタンスでキャッシュが独立しているため、キャッシュから取得した場合にBOM除去処理をスキップしている可能性
- キャッシュキーはBOM除去**前**のテキストを使用しているが、キャッシュから取得した場合はBOM除去処理をスキップしている

**影響**:
- キャッシュから取得した場合、BOM除去処理が実行されない
- キャッシュに保存する際にBOM除去後のテキストを使用しているが、キャッシュキーはBOM除去前のテキストを使用しているため、不一致が発生する可能性

**確認方法**:
- 本番環境のログで`🚀 埋め込みベクトルをキャッシュから取得`を検索して、キャッシュから取得した場合にBOMが含まれているか確認
- キャッシュキーの生成タイミングを確認

**修正方法**:
- キャッシュキーもBOM除去後のテキストを使用する
- または、キャッシュから取得した場合もBOM除去処理を実行する

### 7. **本番環境特有のリクエスト処理**

**問題点**:
- 本番環境では、プロキシ、ロードバランサー、CDNなどがリクエストを処理している可能性がある
- これらのミドルウェアがリクエストボディにBOMを追加している可能性がある
- または、リクエストボディのエンコーディングを変更している可能性がある

**影響**:
- HTTPリクエストボディにBOMが含まれている可能性
- または、リクエストボディのエンコーディングが変更されている可能性

**確認方法**:
- 本番環境のログでHTTPリクエストヘッダーを確認
- プロキシやロードバランサーの設定を確認

### 8. **Node.jsバージョンや文字列処理の違い**

**問題点**:
- 本番環境とローカル環境でNode.jsバージョンが異なる可能性がある
- Node.jsバージョンによって、文字列処理の挙動が異なる可能性がある
- または、V8エンジンのバージョンが異なる可能性がある

**影響**:
- BOM除去処理の挙動が異なる可能性
- ただし、基本的な文字列処理は同じはずなので、この問題は発生しない可能性が高い

**確認方法**:
- 本番環境とローカル環境のNode.jsバージョンを確認
- 文字列処理の挙動を比較

## 最も可能性が高い要因（本番環境特有）

### **要因1: HTTPリクエストボディのエンコーディング処理（最も可能性が高い）**

本番環境では、HTTPリクエストボディがUTF-8でエンコードされているが、BOMが含まれている可能性がある。`req.json()`でパースする際に、BOMが含まれている可能性がある。

**修正方法**:
- `req.json()`でパースする前に、リクエストボディを文字列として取得してBOMを除去
- または、`req.json()`でパースした後、すべての文字列フィールドからBOMを除去
- `src/app/api/streaming-process/route.ts`でBOM除去処理を実行しているが、実行される前にBOMが含まれている可能性があるため、より早期にBOM除去処理を実行する

### **要因2: キャッシュの問題**

本番環境では、複数のインスタンスが動作している可能性がある。各インスタンスでキャッシュが独立しているため、キャッシュから取得した場合にBOM除去処理をスキップしている可能性がある。

**修正方法**:
- キャッシュキーもBOM除去後のテキストを使用する
- または、キャッシュから取得した場合もBOM除去処理を実行する

## 推奨される修正方法（優先順位順）

### 1. **HTTPリクエストボディのBOM除去処理を強化**（最優先）

`src/app/api/streaming-process/route.ts`で、`req.json()`でパースする前に、リクエストボディを文字列として取得してBOMを除去する。

```typescript
// 修正前
const body = await req.json();
let { question, chatHistory = [], labelFilters = { includeMeetingNotes: false } } = body;

// 修正後
const bodyText = await req.text();
const cleanBodyText = bodyText.replace(/\uFEFF/g, '');
const body = JSON.parse(cleanBodyText);
let { question, chatHistory = [], labelFilters = { includeMeetingNotes: false } } = body;
```

### 2. **キャッシュキーをBOM除去後のテキストで生成**

`src/lib/embeddings.ts`で、キャッシュキーをBOM除去後のテキストで生成する。

```typescript
// 修正前
const cacheKey = `embedding:${text.substring(0, 100)}`;

// 修正後
// BOM除去処理の後にキャッシュキーを生成
const cacheKey = `embedding:${text.substring(0, 100)}`;
```

### 3. **キャッシュから取得した場合もBOM除去処理を実行**

`src/lib/embeddings.ts`で、キャッシュから取得した場合もBOM除去処理を実行する。

```typescript
// 修正前
if (cached && Date.now() - cached.timestamp < 15 * 60 * 1000) {
  return cached.embedding;
}

// 修正後
if (cached && Date.now() - cached.timestamp < 15 * 60 * 1000) {
  // キャッシュから取得した場合もBOM除去処理を実行（念のため）
  const cleanText = text.replace(/\uFEFF/g, '');
  if (cleanText !== text) {
    console.warn(`🔍 [BOM REMOVED FROM CACHED] BOM removed from cached text`);
  }
  return cached.embedding;
}
```

### 4. **BOM検出ログを追加**（既に実装済み）

BOM検出ログを追加して、BOMが検出された場合にログを出力する。

## 確認方法

1. **本番環境のログで`[BOM DETECTED]`を検索**
   - `[BOM DETECTED IN getEmbeddings]`
   - `[BOM DETECTED IN getGeminiEmbeddings]`
   - `[BOM DETECTED] searchLanceDB received query with BOM`
   - `[BOM DETECTED IN LANCEDB DATA]`

2. **HTTPリクエストボディにBOMが含まれているか確認**
   - `req.json()`でパースする前後でBOMをチェック
   - HTTPリクエストヘッダーの`Content-Type`や`Content-Encoding`を確認

3. **キャッシュから取得した場合にBOMが含まれているか確認**
   - 本番環境のログで`🚀 埋め込みベクトルをキャッシュから取得`を検索
   - キャッシュから取得した場合にBOMが含まれているか確認

4. **BOM除去処理の前後でテキストを比較**
   - BOM除去処理の前後でテキストを比較して、BOM除去処理が正しく機能しているか確認

