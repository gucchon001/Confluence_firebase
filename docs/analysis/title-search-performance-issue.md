# タイトル検索パフォーマンス問題の分析

## 問題の概要

本番環境でのみ78秒の遅延が発生し、ローカル環境では発生していない。

## 根本原因

### 1. `title`フィールドにインデックスがない

現在作成されているインデックス：
- ✅ ベクトルインデックス（`vector`）
- ✅ スカラーインデックス（`page_id`）
- ✅ スカラーインデックス（`id`）
- ❌ **`title`フィールドのインデックスがない**

### 2. `LIKE '%...%'`パターンはインデックスを効率的に使用できない

```typescript
const like = `%${t.replace(/'/g, "''")}%`;  // 前方一致ではない
const exactRows = await tbl.query().where(`title LIKE '${like}'`).limit(20).toArray();
```

`LIKE '%...%'`パターン（前方一致ではない）は、インデックスがあっても全件スキャンになる可能性が高い。

### 3. 環境による性能差

**ローカル環境**:
- データ量: 1,174件
- 全件スキャン: 各クエリが数十ms程度
- 49個のクエリ順次実行: 約1-2秒

**本番環境**:
- データ量: 1,174件（同じだが、ファイル構造やI/Oが異なる）
- 全件スキャン: 各クエリが約1.6秒
- 49個のクエリ順次実行: **約78秒**

## なぜ本番環境でのみ遅いのか？

### 1. I/Oパフォーマンスの違い

ローカル環境:
- ローカルディスク（SSD）からの読み込み
- ファイルシステムキャッシュが効く
- メモリマッピングが高速

本番環境（Cloud Run）:
- Cloud Storageからダウンロードしたデータ
- ネットワーク経由のI/O
- ファイルシステムキャッシュが効きにくい
- コンテナ環境のオーバーヘッド

### 2. データファイルの構造

ローカル環境:
- 最新のデータ構造
- 最適化されたファイルレイアウト

本番環境:
- Cloud Storageからダウンロードしたデータ
- ファイルレイアウトが最適化されていない可能性
- インデックスファイルの状態が異なる可能性

### 3. リソース制約

Cloud Run:
- CPU/メモリの制限
- ネットワーク帯域の制限
- I/Oスロットリング

## 解決策

### 1. タイトル候補数の制限（実装済み）

```typescript
titles = titles.slice(0, 10);  // 49個 → 10個
```

### 2. 並列実行に変更（実装済み）

```typescript
// 順次実行 → 並列実行
const titleSearchPromises = titles.map(async (t) => {
  return await tbl.query()...
});
await Promise.all(titleSearchPromises);
```

### 3. より効率的な検索方法への変更（推奨）

`LIKE`クエリの代わりに、Lunr検索を使用する：

```typescript
// 現在: LIKEクエリ（全件スキャン）
const exactRows = await tbl.query().where(`title LIKE '${like}'`).limit(20).toArray();

// 推奨: Lunr検索（インデックス使用）
const lunrResults = await lunrSearchClient.search(t, { limit: 20 });
```

### 4. `title`フィールドにインデックスを作成（効果が限定的）

`LIKE '%...%'`パターンでは、インデックスの効果が限定的です。

## 期待される効果

修正後の期待値:
- タイトル候補数: 49個 → 10個（約80%削減）
- 実行方法: 順次実行 → 並列実行（約10倍高速化）
- 合計: **78秒 → 約1-2秒（約98%短縮）**

## 今後の改善案

1. **Lunr検索への移行**: `LIKE`クエリをLunr検索に置き換える
2. **キャッシュの導入**: 頻繁に検索されるタイトル候補をキャッシュ
3. **検索方法の見直し**: タイトル検索の必要性を再評価

