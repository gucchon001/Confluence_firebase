# Jira検索システム 仕様書

**最終更新**: 2025年1月  
**バージョン**: 1.0  
**ステータス**: ✅ 本番稼働中

---

## 1. 概要

### 1.1 目的

Confluence検索システムに、Jiraプロジェクトの課題データを統合し、自然言語による対話形式でJira課題の検索・要約・深掘りを可能にする。開発者やプロダクトマネージャーが、仕様書（Confluence）と課題管理（Jira）を横断的に検索できることで、情報検索コストを削減し、開発効率を向上させることを目的とする。

### 1.2 主要機能

- **Jira課題検索**: ユーザーが自然言語で質問を入力し、関連するJira課題を検索
- **Jira特有フィールド表示**: ステータス、優先度、担当者、Issue KeyなどのJira特有情報を表示
- **ソース切替**: ConfluenceとJiraを切り替えて検索可能
- **AI要約**: 検索結果を基に、AIが要約した回答を生成
- **ストリーミング回答**: リアルタイムで回答を生成・表示

---

## 2. システムアーキテクチャ

### 2.1 全体構成

```
ユーザー → Next.js UI (タブ切替) → API Routes → ハイブリッド検索エンジン
                                                      ↓
                                            ┌─────────┴─────────┐
                                            ↓                   ↓
                                      LanceDB              Lunr.js
                                  (jira_issuesテーブル)  (Jira専用インデックス)
                                            ↓
                                      Gemini API
                                    (回答生成)
```

### 2.2 データフロー

1. **データ同期フロー**
   - Jira REST API (`/rest/api/3/search/jql`) から課題データを取得
   - `nextPageToken`を使用したページネーション（`startAt`は無視される）
   - 課題データを正規化・整形
   - Gemini Embeddings API (text-embedding-004) による埋め込みベクトル生成（768次元）
   - Firestore `jiraIssues`コレクションにrawデータと整形データを保存
   - LanceDB `jira_issues`テーブルに検索用メタデータを保存
   - Firestore `jiraSyncJobs`コレクションに同期履歴を記録

2. **検索フロー**
   - ユーザークエリをGemini Embeddings APIで埋め込みベクトルに変換（768次元）
   - 並列実行による複数検索ソースの組み合わせ：
     - **ベクトル検索**: LanceDB `jira_issues`テーブルで類似ベクトル検索
     - **BM25検索**: Lunr.js Jira専用インデックスによる全文検索
   - ベクトル検索結果から完全なレコードを取得（Jira特有フィールドを補完）
   - BM25検索結果をLanceDBでenrichment（Jira特有フィールドを補完）
   - スコアリング統合（RRF融合 + Composite Scoring）
   - 重複除去と結果統合
   - Gemini APIで回答生成

3. **ストリーミング回答フロー**
   - Confluence検索と同様のストリーミング処理
   - Jira特有フィールドを含む検索結果を表示

---

## 3. データスキーマ

### 3.1 LanceDBスキーマ（jira_issuesテーブル）

```typescript
interface JiraRecord {
  id: string;                    // Issue Key (例: "CTJ-1234")
  vector: number[];              // 768次元の埋め込みベクトル
  issue_key: string;             // Issue Key (例: "CTJ-1234")
  title: string;                 // Summary（課題のタイトル）
  content: string;               // Description + コメント
  status: string;                // ステータス名（例: "完了", "進行中"）
  status_category: string;       // ステータスカテゴリ（例: "完了", "進行中"）
  priority: string;              // 優先度（例: "High", "Medium"）
  assignee: string;              // 担当者（例: "池田広大", "(unassigned)"）
  issue_type: string;            // 課題タイプ（例: "ストーリー", "バグ"）
  reporter: string;              // 報告者
  created_at: string;            // 作成日時（ISO文字列）
  updated_at: string;            // 更新日時（ISO文字列）
  labels_text: string;           // ラベル（カンマ区切り文字列）
  project_key: string;           // プロジェクトキー（例: "CTJ"）
  project_name: string;          // プロジェクト名
  url: string;                   // Jira課題URL
}
```

### 3.2 Firestoreスキーマ

**コレクション: `jiraIssues`**
```typescript
interface JiraIssueDocument {
  id: string;                    // Issue Key
  raw: any;                      // Jira APIからのraw JSON
  normalized: JiraRecord;        // 正規化されたデータ
  syncedAt: Timestamp;           // 同期日時
}
```

**コレクション: `jiraSyncJobs`**
```typescript
interface JiraSyncJobDocument {
  id: string;                    // ジョブID
  status: 'running' | 'completed' | 'failed';
  totalIssues: number;           // 取得件数
  syncedAt: Timestamp;           // 同期日時
  error?: string;                // エラーメッセージ（失敗時）
}
```

### 3.3 重要なフィールド

- **id / issue_key**: `string` - Issue Key（例: "CTJ-1234"）
- **status**: `string` - ステータス名（例: "完了", "進行中", "調査中"）
- **status_category**: `string` - ステータスカテゴリ（例: "完了", "進行中"）
- **priority**: `string` - 優先度（例: "High", "Medium", "Low"）
- **assignee**: `string` - 担当者（未割り当ての場合は "(unassigned)"）
- **issue_type**: `string` - 課題タイプ（例: "ストーリー", "バグ", "タスク"）

---

## 4. 検索システム

### 4.1 ハイブリッド検索コンポーネント

1. **ベクトル検索**
   - Gemini Embedding 768次元
   - コサイン類似度
   - 意味的類似性に基づく検索
   - 検索後、完全なレコードを取得してJira特有フィールドを補完

2. **BM25検索**
   - Lunr.js Jira専用インデックス
   - Kuromojiによる日本語トークン化
   - Okapi BM25アルゴリズム
   - 検索後、LanceDBでenrichmentしてJira特有フィールドを補完

3. **スコアリング統合**
   - RRF融合（Reciprocal Rank Fusion）
   - Composite Scoring（複合スコアリング）

### 4.2 テーブル分離

- **Confluence**: `confluence`テーブル
- **Jira**: `jira_issues`テーブル
- **Lunrインデックス**: テーブルごとに独立したインデックス
  - Confluence: `lunr-index-confluence.msgpack`
  - Jira: `lunr-index-jira_issues.msgpack`

### 4.3 LanceDBClientの複数テーブル対応

`LanceDBClient.getInstance()`は、テーブル名とDBパスの組み合わせごとに異なるインスタンスを管理：

```typescript
const instanceKey = `${dbPath}:${tableName}`;
```

これにより、`getLanceDBTable('jira_issues')`が正しく`jira_issues`テーブルを開く。

---

## 5. API仕様

### 5.1 検索API

**エンドポイント**: `POST /api/search`

**リクエスト**:
```json
{
  "query": "池田担当でステータスがまだ完了していないものは",
  "topK": 10,
  "source": "jira",
  "useHybridSearch": true
}
```

**レスポンス**:
```json
{
  "results": [
    {
      "id": "CTJ-1234",
      "issue_key": "CTJ-1234",
      "title": "応募移管機能の開発",
      "content": "...",
      "url": "https://giginc.atlassian.net/browse/CTJ-1234",
      "status": "進行中",
      "status_category": "進行中",
      "priority": "High",
      "assignee": "池田広大",
      "issue_type": "ストーリー",
      "score": 0.95,
      "scoreText": "Hybrid 0.95"
    }
  ],
  "searchTime": 1234
}
```

### 5.2 ストリーミングAPI

**エンドポイント**: `POST /api/streaming-process`

**リクエスト**: 検索APIと同じ（`source: "jira"`を指定）

**レスポンス**: Server-Sent Events (SSE)形式でストリーミング

---

## 6. UI/UX仕様

### 6.1 ソース切替

- **タブUI**: Radix UI Tabsを使用
- **タブ**: `Confluence`（初期表示）、`Jira`
- **アクティブタブ**: アクセントライン＋太字で表示

### 6.2 Jira検索結果表示

- **タイトル**: Summary（課題のタイトル）
- **Issue Key**: バッジ表示 + Jiraへのリンク
- **ステータス**: バッジ表示 + ステータスカテゴリー色
- **優先度**: バッジ表示
- **担当者**: テキスト表示
- **種別**: テキスト表示
- **コンテンツ**: Description + コメントの抜粋
- **URL**: Jira課題へのディープリンク

### 6.3 検索結果カード例

```
┌─────────────────────────────────────────┐
│ 応募移管機能の開発                      │
│ CTJ-1234  [進行中]  [High]              │
│ 担当者: 池田広大                        │
│ 種別: ストーリー                        │
│                                         │
│ 応募者を別の教室に移管する機能の開発... │
│                                         │
│ https://giginc.atlassian.net/browse/... │
└─────────────────────────────────────────┘
```

---

## 7. データ同期

### 7.1 同期方式

- **APIエンドポイント**: `/rest/api/3/search/jql`
- **ページネーション**: `nextPageToken`を使用（`startAt`は無視される）
- **JQLクエリ**: `project = "CTJ" ORDER BY updated DESC`
- **取得フィールド**: `summary`, `description`, `status`, `priority`, `assignee`, `reporter`, `created`, `updated`, `labels`, `issuetype`, `project`, `comment` + カスタムフィールド
- **差分取得**: ✅ 実装済み（既存データの`updated`フィールドと比較して、変更されたデータのみ更新）
- **LanceDB反映**: 差分アップサート（テーブルが空または欠損している場合のみ全件再構築）

### 7.2 同期スクリプト

```bash
# 全件同期（差分取得機能により、変更されたデータのみ更新）
npm run sync:jira

# 最大件数指定（例: 200件）
JIRA_MAX_ISSUES=200 npm run sync:jira
```

### 7.3 同期処理フロー

1. Jira APIから課題データを取得（`nextPageToken`を使用）
2. 課題データを正規化・整形
3. **差分チェック**: 既存データの`updated`フィールドと比較
   - 新規追加: 存在しない課題は追加
   - 更新: `updated`が1秒以上新しい課題のみ更新
   - 変更なし: 1秒以内の差の課題はスキップ
4. Firestore `jiraIssues`に保存（バッチ処理: 50件/バッチ、変更があったもののみ）
5. ベクトル生成（バッチ処理: 50件/バッチ、10並列、リトライロジック付き）
6. LanceDB `jira_issues`テーブルに保存（差分アップサート / テーブルが空の場合は全件再構築）
7. Firestore `jiraSyncJobs`に同期履歴を記録（追加・更新・変更なしの統計情報を含む）

### 7.4 差分取得の詳細

- **比較方法**: 既存データの`updated`フィールドとJira APIから取得した`updated`フィールドを比較
- **更新判定**: Jiraの`updated`が既存データより1秒以上新しい場合のみ更新
- **統計情報**: 同期結果に`added`（追加）、`updated`（更新）、`unchanged`（変更なし）の件数が含まれる
- **パフォーマンス**: 変更がないデータはスキップされるため、同期時間とAPIコール数を削減

### 7.5 進捗ログ

- Firestore保存: 10%ごとに進捗ログ（追加・更新・変更なしの統計情報を含む）
- ベクトル生成: 50件ごとに進捗ログ
- エラー発生時: エラーメッセージとスタックトレースを記録
- 差分情報: 新規追加・更新された課題のキーとタイトルをログ出力

---

## 8. Lunrインデックス

### 8.1 インデックス初期化

```bash
# Jira Lunrインデックスの初期化
npm run init:jira-lunr
```

### 8.2 インデックス構造

- **テーブル名**: `jira_issues`
- **キャッシュファイル**: `.cache/lunr-index-jira_issues.msgpack`
- **ドキュメント数**: 同期済み課題数（例: 5,427件）

### 8.3 インデックスフィールド

- `tokenizedTitle`: タイトル（トークン化済み）
- `tokenizedContent`: コンテンツ（トークン化済み）
- `labels`: ラベル
- `issue_key`: Issue Key
- `status`: ステータス
- `status_category`: ステータスカテゴリ
- `priority`: 優先度
- `assignee`: 担当者
- `issue_type`: 課題タイプ

### 8.4 インデックス再構築

キャッシュファイルを削除して再初期化：

```bash
# キャッシュファイルを削除
rm .cache/lunr-index-jira_issues.msgpack
rm .cache/lunr-index-jira_issues.json

# インデックスを再初期化
npm run init:jira-lunr
```

---

## 8.5 LanceDBインデックス

### 8.5.1 ベクトルインデックス（IVF_PQ）

**用途**: ベクトル類似度検索の高速化

**インデックスタイプ**: IVF_PQ (Inverted File with Product Quantization)

**設定パラメータ**:
- `numPartitions`: 256（パーティション数）
- `numSubVectors`: 16（サブベクトル数）
- `vector`: 768次元（Gemini Embedding API text-embedding-004）

**作成方法**:
```bash
# LanceDBインデックスを作成（全テーブル対象）
npx tsx scripts/create-lancedb-indexes.ts

# または npm スクリプト経由
npm run lancedb:create-indexes
```

**作成タイミング**:
- データ同期後（`npm run sync:jira`実行後）
- テーブル再構築後
- 本番環境デプロイ前

**確認方法**:
- `scripts/create-lancedb-indexes.ts`を実行すると、既存インデックスの場合は「既に存在します」と表示される

### 8.5.2 スカラーインデックス（issue_key）

**用途**: `issue_key`フィールドでの高速検索・フィルタリング

**インデックスタイプ**: BTree

**対象フィールド**: `issue_key`（例: "CTJ-1234"）

**作成方法**:
- `scripts/create-lancedb-indexes.ts`を実行すると自動的に作成される
- Jiraテーブル（`jira_issues`）専用のスカラーインデックス

**使用例**:
- 特定のIssue Keyでの直接検索
- 検索結果のフィルタリング
- 重複チェック

### 8.5.3 インデックス作成フロー

1. **データ同期**: `npm run sync:jira`でデータをLanceDBに保存
2. **インデックス作成**: `npm run lancedb:create-indexes`でインデックスを作成
3. **検証**: 検索パフォーマンスを確認

**注意事項**:
- インデックス作成には時間がかかる場合があります（5,430件で約3.67秒）
- 既存インデックスがある場合はスキップされます
- テーブル再構築後は必ずインデックスを再作成してください

---

## 9. パフォーマンス

### 9.1 検索性能

- **平均検索時間**: 100-300ms（Confluenceと同等）
- **ベクトル次元**: 768次元
- **対応課題数**: 最大10,000課題

### 9.2 同期性能

- **全件同期時間**: 約5,000課題で30-60分
- **ベクトル生成**: 50件/バッチ、10並列
- **Firestore保存**: 500件/バッチ

### 9.3 最適化ポイント

1. **テーブル分離**: ConfluenceとJiraでテーブルを分離
2. **インデックス分離**: 
   - Lunrインデックスをテーブルごとに管理
   - LanceDBベクトルインデックス（IVF_PQ）でベクトル検索を高速化
   - LanceDBスカラーインデックス（issue_key）でフィールド検索を高速化
3. **並列処理**: ベクトル生成とFirestore保存を並列化
4. **バッチ処理**: 大量データをバッチで処理
5. **インデックス最適化**: 
   - ベクトルインデックス（IVF_PQ）: 256パーティション、16サブベクトル
   - スカラーインデックス（issue_key）: BTreeインデックス

---

## 10. エラーハンドリング

### 10.1 同期エラー

- **タイムアウト**: ベクトル生成のタイムアウトを30秒に設定
- **リトライロジック**: ベクトル生成失敗時に最大3回リトライ
- **エラーログ**: Firestore `jiraSyncJobs`にエラーを記録

### 10.2 検索エラー

- **テーブル不存在**: エラーメッセージを表示
- **インデックス未初期化**: 自動初期化を試行
- **フィールド欠損**: デフォルト値（"N/A"）を表示

---

## 11. 運用・メンテナンス

### 11.1 定期同期

- **推奨頻度**: 1日1回（夜間）
- **実行方法**: Cloud Run Scheduler or 手動実行
- **監視**: Firestore `jiraSyncJobs`で同期状態を確認

### 11.2 インデックス更新

#### Lunrインデックス更新

- **更新タイミング**: データ同期後
- **更新方法**: `npm run init:jira-lunr`

#### LanceDBインデックス更新

- **更新タイミング**: データ同期後、テーブル再構築後
- **更新方法**: `npm run lancedb:create-indexes`
- **対象インデックス**:
  - ベクトルインデックス（IVF_PQ）: ベクトル検索の高速化
  - スカラーインデックス（issue_key）: フィールド検索の高速化

### 11.3 データ確認

```bash
# LanceDBテーブル確認
npx tsx src/scripts/check-lancedb-tables.ts

# Firestoreデータ確認
npx tsx src/scripts/check-jira-firestore.ts
```

---

## 12. 技術スタック

### 12.1 共通技術（Confluenceと同様）

- **フレームワーク**: Next.js 15.3.3
- **言語**: TypeScript 5.9.2
- **AI**: Google AI - Gemini API
- **ベクトルDB**: LanceDB 0.22.0
- **検索エンジン**: Lunr.js 2.3.9

### 12.2 Jira固有技術

- **Jira API**: REST API v3 (`/rest/api/3/search/jql`)
- **ページネーション**: `nextPageToken`（`startAt`は使用しない）
- **認証**: Basic認証（Email + API Token）

---

## 13. 環境変数

```bash
# Jira API設定
JIRA_BASE_URL=https://giginc.atlassian.net
JIRA_USER_EMAIL=your-email@example.com
JIRA_API_TOKEN=your-api-token
JIRA_PROJECT_KEY=CTJ

# 同期設定
JIRA_MAX_ISSUES=0  # 0の場合は全件取得
```

---

## 14. 関連ドキュメント

- [Confluence検索システム仕様](./02.02-confluence-spec.md)
- [LanceDB統合ガイド](../01-architecture/01.02.04-lancedb-integration-guide.md)
- [Jira統合計画](../01-architecture/06.01.01-confluence-jira-integration-plan.md)
- [Jiraデータフロー](../archive/architecture-legacy/jira-data-flow-lancedb.md) (アーカイブ済み、上記に統合済み)

---

## 15. 更新履歴

**2025年1月**: 初版作成
- Jira検索機能の統合完了
- LanceDBへのJiraデータ投入完了
- LunrインデックスのJira対応完了
- ハイブリッド検索エンジンのJira対応完了
- Jira特有フィールドの取得・表示完了
- BM25検索のenrichment処理の修正完了
- LanceDBClientの複数テーブル対応完了
- ソース切替UI（タブ）の実装完了

