# Confluence / Jira 検索実装の違い（詳細版）

**作成日**: 2025年1月  
**最終更新**: 2025年1月  
**ステータス**: 📋 実装詳細比較

---

## 目次

1. [検索タイプの違い](#1-検索タイプの違い)
2. [BM25検索の実装違い](#2-bm25検索の実装違い)
3. [RRF計算の違い](#3-rrf計算の違い)
4. [結果補完処理の違い](#4-結果補完処理の違い)
5. [データ取得方法の違い](#5-データ取得方法の違い)
6. [今回の修正の影響](#6-今回の修正の影響)

---

## 1. 検索タイプの違い

### 1.1 検索タイプ一覧

| 検索タイプ | Confluence | Jira | 実装場所 |
|-----------|-----------|------|---------|
| **ベクトル検索** | ✅ | ✅ | `executeVectorSearch()` |
| **BM25検索** | ✅ | ✅ | `executeBM25Search()` |
| **キーワード検索（LanceDB LIKE）** | ✅ | ❌ | `executeKeywordSearch()` |
| **タイトル救済検索** | ✅ | ❌ | `executeTitleRescueSearch()` |
| **タイトル厳格一致検索** | ✅ | ❌ | `executeTitleExactSearch()` |

### 1.2 実装コードでの違い

**Confluence** (`tableName === 'confluence'`):
```typescript
// 4種類の検索タイプを実行
const vectorResults = await executeVectorSearch(...);
const keywordResults = await executeKeywordSearch(...); // Confluenceのみ
const bm25Results = await executeBM25Search(...);
const titleRescueResults = await executeTitleRescueSearch(...); // Confluenceのみ
```

**Jira** (`tableName === 'jira_issues'`):
```typescript
// 2種類の検索タイプのみ実行
const vectorResults = await executeVectorSearch(...);
const bm25Results = await executeBM25Search(...);
// キーワード検索とタイトル救済検索はスキップ
```

---

## 2. BM25検索の実装違い

### 2.1 データ取得方法の違い

**Confluence** (`tableName === 'confluence'`):
```typescript
// page_idでLanceDBからレコードを取得
const uniquePageIds = Array.from(
  new Set(
    allLunrResults
      .map(result => getPageIdFromRecord(result) || result.page_id || result.pageId)
      .filter((id): id is number => id !== null && Number.isFinite(id) && id > 0)
  )
);

// page_idでクエリ
const pageIdConditions = chunk.map(id => `\`page_id\` = ${id}`).join(' OR ');
const rows = await tbl.query().where(`(${pageIdConditions})`).toArray();
```

**Jira** (`tableName === 'jira_issues'`):
```typescript
// id（issue_key）でLanceDBからレコードを取得
const uniqueIssueKeys = Array.from(
  new Set(
    allLunrResults
      .map(result => result.id || result.issue_key)
      .filter(Boolean)
  )
);

// id（issue_key）でクエリ
const idConditions = chunk.map(key => `\`id\` = '${key}'`).join(' OR ');
const rows = await tbl.query().where(`(${idConditions})`).limit(chunk.length).toArray();
```

### 2.2 結果補完処理の違い

**Confluence**:
- `page_id`でLanceDBからレコードを取得
- `pageId`と`page_id`の両方のフィールド名に対応（マイグレーション対応）
- `mapLanceDBRecordToAPI()`でBigInt対応

**Jira**:
- `id`（issue_key）でLanceDBからレコードを取得
- Jira特有フィールド（`status`, `priority`, `assignee`, `issue_type`等）を補完
- `issue_key`を確実に設定

### 2.3 実装コード（`executeBM25Search`関数内）

```typescript
// Jiraテーブルの場合、id（issue_key）で取得、Confluenceテーブルの場合、page_idで取得
if (tableName === 'jira_issues') {
  // Jiraテーブル: id（issue_key）で取得
  const uniqueIssueKeys = Array.from(
    new Set(
      allLunrResults
        .map(result => result.id || result.issue_key)
        .filter(Boolean)
    )
  );
  // ... idでクエリ
} else {
  // Confluenceテーブル: page_idで取得（既存の処理）
  const uniquePageIds = Array.from(
    new Set(
      allLunrResults
        .map(result => {
          const pageId = getPageIdFromRecord(result) || result.page_id || result.pageId;
          return pageId ? Number(pageId) : null;
        })
        .filter((id): id is number => id !== null && Number.isFinite(id) && id > 0)
    )
  );
  // ... page_idでクエリ
}
```

---

## 3. RRF計算の違い

### 3.1 RRF計算の共通実装

**実装場所**: `src/lib/unified-search-result-processor.ts`の`applyRRFFusion()`関数

**共通点**:
- ConfluenceとJiraで**同じRRF計算ロジック**を使用
- 重み: `vector=1.0`, `keyword=0.8`, `title-exact=1.2`, `bm25=0.6`
- RRF K値: `60`（デフォルト）

### 3.2 RRF順位計算の違い

**Confluence**:
```typescript
const byVector = [...results].sort((a, b) => (a._distance ?? 1) - (b._distance ?? 1));
const byKeyword = [...results].sort((a, b) => (b._keywordScore ?? 0) - (a._keywordScore ?? 0));
const byTitleExact = results.filter(r => r._sourceType === 'title-exact');
const byBm25 = results.filter(r => r._bm25Score !== undefined && r._bm25Score !== null)
  .sort((a, b) => (b._bm25Score ?? 0) - (a._bm25Score ?? 0));
```

**Jira**:
```typescript
// 同じロジックを使用（keywordとtitle-exactは存在しない場合が多い）
const byVector = [...results].sort((a, b) => (a._distance ?? 1) - (b._distance ?? 1));
const byKeyword = [...results].sort((a, b) => (b._keywordScore ?? 0) - (a._keywordScore ?? 0));
const byTitleExact = results.filter(r => r._sourceType === 'title-exact');
const byBm25 = results.filter(r => r._bm25Score !== undefined && r._bm25Score !== null)
  .sort((a, b) => (b._bm25Score ?? 0) - (a._bm25Score ?? 0));
```

**違い**:
- 実装ロジックは共通だが、**どのソースタイプがどのくらい出現するか**が異なる
  - Confluence: `keyword`・`title-exact`ソース（キーワード検索・タイトル救済検索）の結果が比較的多い
  - Jira: 検索タイプが「ベクトル + BM25」のみのため、`_sourceType: 'title-exact'`は「Issue Key完全一致」や「タイトル救済検索」がヒットした場合に限られる
- `_keywordScore`は両方で常に計算されるため、**Jiraでも`keyword`順位は通常有効**（`undefined`にはならない）
- `title-exact`順位は、**タイトル救済検索 / Issue Key完全一致がヒットした場合のみ有効**（ヒットしなければ`undefined`で寄与0）

### 3.3 今回の修正の影響

**修正前**:
```typescript
const byBm25 = results.filter(r => r._sourceType === 'bm25');
```

**修正後**:
```typescript
// ★★★ 修正: _bm25Scoreが定義されている結果をBM25順位に含める（_sourceTypeに関係なく） ★★★
const byBm25 = results.filter(r => r._bm25Score !== undefined && r._bm25Score !== null)
  .sort((a, b) => (b._bm25Score ?? 0) - (a._bm25Score ?? 0));
```

**影響**:
- **Confluence**: `_sourceType === 'title-exact'`の結果でも`_bm25Score`が定義されていればBM25順位に含まれる
- **Jira**: `_sourceType === 'hybrid'`の結果でも`_bm25Score`が定義されていればBM25順位に含まれる
- **共通**: BM25検索の結果が正しくRRF計算に含まれるようになった

---

## 4. 結果補完処理の違い

### 4.1 ベクトル検索結果の補完

**Confluence**:
- 補完処理なし（LanceDBから直接取得したデータを使用）

**Jira**:
```typescript
// Jiraテーブルの場合、ベクトル検索結果から完全なレコードを取得
if (tableName === 'jira_issues' && vectorResults.length > 0) {
  const issueKeys = vectorResults
    .map(r => r.id || r.issue_key)
    .filter(Boolean)
    .slice(0, Math.min(vectorResults.length, 300));
  
  if (issueKeys.length > 0) {
    const idConditions = issueKeys.map(key => `\`id\` = '${key}'`).join(' OR ');
    const fullRecords = await tbl.query()
      .where(`(${idConditions})`)
      .limit(issueKeys.length)
      .toArray();
    // ... 完全なレコードで置き換え
  }
}
```

### 4.2 BM25検索結果の補完

**Confluence**:
- `page_id`でLanceDBからレコードを取得
- `mapLanceDBRecordToAPI()`でBigInt対応

**Jira**:
- `id`（issue_key）でLanceDBからレコードを取得
- Jira特有フィールド（`status`, `priority`, `assignee`, `issue_type`等）を補完

---

## 5. データ取得方法の違い

### 5.1 ID形式の違い

| 項目 | Confluence | Jira |
|------|-----------|------|
| **ID形式** | `page_id` (number, int64) | `issue_key` (string, 例: "CTJ-1234") |
| **LanceDBでの取得** | `page_id`でクエリ | `id`（issue_key）でクエリ |
| **重複判定** | `pageId`で重複判定 | `issue_key`で重複判定 |

### 5.2 実装コードでの違い

**Confluence** (`deduplicateByPageId`関数内):
```typescript
const isJiraTable = tableName === 'jira_issues';

for (const result of results) {
  let key: string;
  if (isJiraTable) {
    // Jiraテーブルの場合: issue_keyで重複判定
    const issueKey = result.issue_key || result.id || '';
    key = `jira:${issueKey}`;
  } else {
    // Confluenceテーブルの場合: pageIdで重複判定
    const pageId = getPageIdFromRecord(result) || '';
    key = `${pageId}::${(result.title || '').toLowerCase()}`;
  }
  // ...
}
```

---

## 6. 今回の修正の影響

### 6.1 修正内容

**ファイル**: `src/lib/unified-search-result-processor.ts`

**修正前**:
```typescript
const byBm25 = results.filter(r => r._sourceType === 'bm25');
```

**修正後**:
```typescript
// ★★★ 修正: _bm25Scoreが定義されている結果をBM25順位に含める（_sourceTypeに関係なく） ★★★
const byBm25 = results.filter(r => r._bm25Score !== undefined && r._bm25Score !== null)
  .sort((a, b) => (b._bm25Score ?? 0) - (a._bm25Score ?? 0));
```

### 6.2 影響範囲

**Confluence**:
- `_sourceType === 'title-exact'`の結果でも`_bm25Score`が定義されていればBM25順位に含まれる
- タイトル救済検索の結果がBM25順位に含まれる可能性がある

**Jira**:
- `_sourceType === 'hybrid'`の結果でも`_bm25Score`が定義されていればBM25順位に含まれる
- ベクトル検索とBM25検索の両方で見つかった結果がBM25順位に含まれる

**共通**:
- BM25検索の結果が正しくRRF計算に含まれるようになった
- RRFスコアにBM25順位の寄与が正しく反映される

### 6.3 テスト結果

**Jira** (`indeed`クエリ):
- 修正前: `BM25順位: N/A (寄与: 0.000000)`
- 修正後: `BM25順位: 1 (寄与: 0.009836)`

**Confluence**:
- 同様の改善が期待される（タイトル救済検索の結果がBM25順位に含まれる場合）

---

## 7. まとめ

### 7.1 主な違い

1. **検索タイプ数**: Confluenceは4種類、Jiraは2種類
2. **データ取得方法**: Confluenceは`page_id`、Jiraは`id`（issue_key）
3. **結果補完**: JiraはJira特有フィールドを補完する処理がある
4. **RRF計算**: 共通実装だが、Confluenceは`keyword`と`title-exact`の寄与がある

### 7.2 共通点

1. **RRF計算ロジック**: 同じ`unified-search-result-processor.ts`を使用
2. **BM25検索**: 同じ`executeBM25Search()`関数を使用（`tableName`で切り替え）
3. **ベクトル検索**: 同じ`executeVectorSearch()`関数を使用
4. **Composite Scoring**: 同じ`CompositeScoringService`を使用

### 7.3 今回の修正の効果

- **Jira**: BM25検索の結果が正しくRRF計算に含まれるようになった
- **Confluence**: タイトル救済検索の結果がBM25順位に含まれる可能性がある
- **共通**: `_bm25Score`が定義されている結果は、`_sourceType`に関係なくBM25順位に含まれる

---

## 8. 関連ドキュメント

- [Confluence / Jira 仕様比較](./02.04-confluence-jira-comparison.md)
- [Confluence検索システム仕様](./02.02-confluence-spec.md)
- [Jira検索システム仕様](./02.03-jira-spec.md)
- [ハイブリッド検索システム仕様](../01-architecture/02.01.02-hybrid-search-specification.md)

---

**最終更新**: 2025年1月  
**作成者**: AI Assistant  
**レビュー**: 未実施

