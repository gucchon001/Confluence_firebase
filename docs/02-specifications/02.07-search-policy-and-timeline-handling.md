# 検索方針と時系列情報の扱い

**作成日**: 2025-01-27  
**最終更新**: 2025-01-27  
**ステータス**: 📝 現在の方針まとめ

---

## 📋 概要

このドキュメントでは、現在の検索システムの基本方針と、時系列情報（最新性）の扱いについて整理します。

---

## 🔍 現在の検索方針（2025年1月時点）

### 基本原則

1. **関連性を最優先**: 検索結果はクエリとの関連性（スコア）でランキングされる
2. **複数のシグナルを統合**: 単一の指標ではなく、複数の検索手法を組み合わせる
3. **明確な優先順位**: スコアリングに明確な重み付けを設定

### スコアリング方式

#### 複合スコア計算式

```
最終スコア = 
  BM25スコア      × 53% +
  タイトルマッチ  × 26% +
  ラベルスコア    × 16% +
  ベクトルスコア  × 5%
```

#### 重み設定の理由

| コンポーネント | 重み | 理由 |
|--------------|------|------|
| **BM25** | 53% | キーワード完全一致を最優先 |
| **タイトル** | 26% | タイトルマッチを強く評価 |
| **ラベル** | 16% | StructuredLabel品質管理 |
| **ベクトル** | 5% | 意味的類似性（ベクトル空間変化対策で最小化） |

### 検索コンポーネント

#### 1. ベクトル検索
- **モデル**: text-embedding-004 (768次元)
- **距離**: コサイン類似度
- **閾値**: maxDistance = 2.0
- **重み**: 5%（最小化）

#### 2. キーワード検索（BM25）
- **エンジン**: Lunr.js + Kuromoji
- **アルゴリズム**: Okapi BM25
- **重み**: 53%（最優先）

#### 3. タイトル救済検索
- **方式**: LanceDB LIKE検索
- **重み**: 26%（タイトルマッチ）

#### 4. Knowledge Graph拡張
- **ステータス**: Phase 7で無効化（パフォーマンス最適化のため）

### 最終ソート方法

```typescript
// 現在の実装（src/lib/lancedb-search-client.ts 参照）

// 1. Issue Key完全一致を最優先
if (aIsIssueKeyExact && !bIsIssueKeyExact) return -1;

// 2. RRFスコアで降順ソート
return bScore - aScore; // スコアが高い順
```

**現在の方針**:
- ✅ Issue Key完全一致を最優先
- ✅ 統合スコア（RRFスコア）で降順ソート
- ❌ **最新性（更新日時）は考慮されていない**

---

## ⏰ 時系列情報の扱い

### 現在の実装状況

#### 1. データとしての保存

時系列情報は以下のフィールドで保存されています：

- **Confluence**: `lastUpdated`（文字列形式のISO日時）
- **Jira**: `updated_at`（文字列形式のISO日時）

#### 2. 検索結果での扱い

```typescript
// src/lib/lancedb-search-client.ts
export interface LanceDBSearchResult {
  // ...
  lastUpdated?: string;    // Confluence用
  updated_at?: string;     // Jira用
  // ...
}
```

**現状**: 時系列情報は**データとして保持されているが、スコアリングやソートには使用されていない**

#### 3. 他の機能での利用

##### Jiraダッシュボード
```typescript:615:620:src/lib/jira-dashboard-service.ts
// 更新日時でソート（新しい順）
result.sort((a, b) => {
  const dateA = new Date(a.updated_at || 0).getTime();
  const dateB = new Date(b.updated_at || 0).getTime();
  return dateB - dateA;
});
```

**Jiraダッシュボードでは時系列ソートを実装しているが、検索結果では未実装**

---

## 🎯 時系列情報の重要性と課題

### ユーザーの指摘

> 「最新の情報の方が価値は高いですが、経緯は時系列で整理する必要がありますよね」

### 現在の課題

1. **最新性が考慮されていない**
   - スコアが同じ場合、古い情報と新しい情報が同列に扱われる
   - 更新日時は表示されるが、ランキングに影響しない

2. **経緯の時系列整理**
   - 検索結果はスコア順のみ
   - 時系列での整理（新しい順/古い順）のオプションがない

3. **トレードオフの検討が必要**
   - **関連性 vs 最新性**: どちらを優先するか
   - **スコアが高い古い情報 vs スコアが低い新しい情報**: どちらを上位に表示するか

---

## 💡 改善の方向性

### 1. 最新性をスコアリングに組み込む（提案）

#### オプションA: 軽微なブースト

```typescript
// 更新日時による軽微なブースト（±5%以内）
const recencyBoost = calculateRecencyBoost(lastUpdated);
finalScore = finalScore * (1 + recencyBoost);

function calculateRecencyBoost(lastUpdated: string): number {
  const daysSinceUpdate = (Date.now() - new Date(lastUpdated).getTime()) / (1000 * 60 * 60 * 24);
  
  // 1年以内: +5%
  if (daysSinceUpdate <= 365) return 0.05;
  // 2年以内: +2%
  if (daysSinceUpdate <= 730) return 0.02;
  // それ以上: 0%
  return 0;
}
```

**メリット**:
- 関連性を最優先しつつ、最新性も考慮
- 既存のランキングを大きく崩さない

**デメリット**:
- 非常に古い重要な情報が下位になる可能性

#### オプションB: 同スコア時のタイブレーカー

```typescript
// スコアが同じ（または非常に近い）場合のみ、最新性でソート
if (Math.abs(aScore - bScore) < 0.01) {
  return new Date(b.lastUpdated).getTime() - new Date(a.lastUpdated).getTime();
}
return bScore - aScore;
```

**メリット**:
- 関連性を完全に優先
- 同点の場合のみ最新性を考慮

**デメリット**:
- 最新性の影響が限定的

### 2. UIで時系列ソートオプションを提供（提案）

検索結果画面で、ユーザーが選択できるように：

```
[スコア順] [新しい順] [古い順]
```

**メリット**:
- ユーザーが目的に応じて選択可能
- 既存のランキングを変更しない

**デメリット**:
- デフォルト表示はスコア順のまま

### 3. 経緯の時系列整理（提案）

特定のクエリパターン（例: 「対応の経緯」「進捗」「履歴」）では、時系列ソートを優先的に適用：

```typescript
const timelineKeywords = ['経緯', '進捗', '履歴', '時系列', '順序'];
const isTimelineQuery = timelineKeywords.some(keyword => query.includes(keyword));

if (isTimelineQuery) {
  // 時系列でソート（新しい順）
  results.sort((a, b) => {
    return new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime();
  });
}
```

---

## 📊 現在の検索フロー（時系列なし）

```
1. クエリ受信
   ↓
2. 並列検索実行
   ├─ ベクトル検索
   ├─ BM25検索
   └─ タイトル救済検索
   ↓
3. RRF融合
   └─ 各検索結果の順位を統合
   ↓
4. 複合スコアリング
   └─ BM25(53%) + タイトル(26%) + ラベル(16%) + ベクトル(5%)
   ↓
5. 最終ソート
   ├─ Issue Key完全一致を最優先
   └─ 統合スコア降順
   ↓
6. 結果返却（時系列は考慮されない）
```

---

## 🔄 改善後の検索フロー（提案）

### オプションA: 軽微なブースト方式

```
5. 最終ソート
   ├─ Issue Key完全一致を最優先
   ├─ 統合スコア降順
   └─ 最新性ブースト適用（±5%以内）
   ↓
6. 結果返却
```

### オプションB: UIオプション方式

```
5. 最終ソート
   ├─ Issue Key完全一致を最優先
   ├─ ユーザー選択に応じて：
   │   ├─ スコア順（デフォルト）
   │   ├─ 新しい順
   │   └─ 古い順
   ↓
6. 結果返却
```

---

## 📝 まとめ

### 現在の方針

1. ✅ **関連性を最優先**: スコアリングベースのランキング
2. ✅ **複数シグナル統合**: BM25(53%) + タイトル(26%) + ラベル(16%) + ベクトル(5%)
3. ✅ **明確な優先順位**: Issue Key完全一致 > 統合スコア
4. ❌ **最新性は未考慮**: 時系列情報は保存されているが、ランキングに影響しない

### 改善提案

1. **最新性をスコアリングに組み込む**（オプションAまたはB）
2. **UIで時系列ソートオプションを提供**
3. **特定クエリパターンで時系列優先ソート**

### 次のステップ

1. 改善方針の決定（軽微なブースト vs UIオプション vs 両方）
2. プロトタイプの実装とテスト
3. ユーザーフィードバックの収集
4. 本番環境への反映

---

## 🔗 関連ドキュメント

- [ハイブリッド検索 クイックリファレンス](../01-architecture/02.01.01-hybrid-search-quick-reference.md)
- [ハイブリッド検索システム 最新仕様書](../01-architecture/02.01.02-hybrid-search-specification.md)
- [Composite Scoring サービス実装](../../src/lib/composite-scoring-service.ts)

---

**最終更新日**: 2025-01-27  
**次回レビュー**: 改善方針決定時

