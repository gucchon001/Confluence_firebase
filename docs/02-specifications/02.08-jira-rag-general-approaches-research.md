# JiraをRAGソースとして使用する一般的な方法の調査

**作成日**: 2025-01-27  
**最終更新**: 2025-01-27  
**ステータス**: 📝 調査結果まとめ

---

## 📋 概要

JiraのデータをRAG（Retrieval-Augmented Generation）システムに統合する際の一般的なアプローチを調査し、現在の実装と比較しました。

---

## 🔍 一般的なアプローチ（研究・実装例より）

### 1. データ抽出と前処理

#### 一般的な方法

**データソース**:
- Jira REST APIを使用して課題、コメント、プロジェクト情報を取得
- データエクスポート機能（CSV/JSON）の活用

**前処理のポイント**:
1. **HTMLタグの除去**: Jiraの説明フィールドなどに含まれるHTMLをテキストに変換
2. **ノイズ除去**: 不要な情報（自動生成コメント、システムメッセージなど）を除去
3. **データ正規化**: 日付形式、ステータス名などの統一
4. **テキストクリーニング**: 特殊文字、改行コードの正規化

**参考研究**: RAG4Tickets（JiraとGitHubのデータを統合したRAGシステム）

#### 現在の実装との比較

```typescript
// 現在の実装（src/lib/jira-sync-service.ts）
// ✅ Jira REST APIを使用
// ✅ HTMLタグの除去
// ✅ データ正規化
// ✅ テキストクリーニング
```

**評価**: ✅ 一般的なアプローチと一致

---

### 2. チャンキング戦略

#### 一般的な方法

**アプローチA: Issue単位でチャンク**
- 1つのIssueを1つのチャンクとして扱う
- **メリット**: シンプル、Issue全体の文脈を保持
- **デメリット**: 長いIssueは埋め込み品質が低下

**アプローチB: セマンティックチャンキング**
- Issueを意味的な単位で分割（タイトル、説明、コメントなど）
- **メリット**: より細かい検索が可能
- **デメリット**: Issue全体の文脈が失われる可能性

**アプローチC: 階層的チャンキング**
- Issue全体 + セクション別チャンクの両方を作成
- **メリット**: 全体と部分の両方から検索可能
- **デメリット**: ストレージとインデックスサイズが増加

#### 現在の実装

```typescript
// 現在の実装（docs/02-specifications/02.04-confluence-jira-comparison.md）
// ❌ Jiraはチャンク分割なし（Issue単位）
```

**評価**: 
- ✅ 一般的なアプローチAを採用
- ⚠️ 長いIssue（コメント多数）の場合は検索精度が低下する可能性

**改善提案**: 
- 長いIssue（例: 1000文字以上）の場合、セマンティックチャンキングを検討
- コメント数が多いIssueは、コメントを個別チャンクとして扱う

---

### 3. データのベクトル化（埋め込み）

#### 一般的な方法

**埋め込みモデル**:
- **Sentence-Transformers**: 一般的に使用される（例: `sentence-transformers/all-MiniLM-L6-v2`）
- **ドメイン固有モデル**: Jiraなどの技術文書に特化したモデル
- **マルチモーダル**: テキスト + メタデータ（ステータス、優先度など）を統合

**埋め込み対象**:
1. **タイトル + 説明**: Issueの主要な情報
2. **コメント**: 解決策や議論の内容
3. **メタデータ**: ステータス、優先度、ラベルなどの構造化情報

**参考研究**: 
- RAG4Tickets: Sentence-TransformersとFAISSを組み合わせ
- ER-RAG: 異種データソース（Jira、GitHubなど）を統一的にモデル化

#### 現在の実装

```typescript
// 現在の実装（docs/02-specifications/02.03-jira-spec.md）
// ✅ Gemini Embeddings API (768次元)
// ✅ タイトル + 説明 + メタデータを含む
```

**評価**: ✅ 一般的なアプローチと一致（高品質な埋め込みモデルを使用）

---

### 4. ベクトルデータベースとインデックス

#### 一般的な方法

**ベクトルデータベース**:
- **FAISS**: 高速な類似検索（メモリベース）
- **Pinecone**: マネージドサービス
- **Weaviate**: スキーマ定義可能
- **LanceDB**: 最新のアプローチ（メモリ効率が良い）

**インデックス方式**:
- **IVF (Inverted File Index)**: 高速検索
- **HNSW (Hierarchical Navigable Small World)**: 高精度
- **PQ (Product Quantization)**: メモリ効率

**全文検索インデックス**:
- **Elasticsearch**: エンタープライズ向け
- **Lunr.js**: 軽量、クライアントサイドでも動作可能

#### 現在の実装

```typescript
// 現在の実装
// ✅ LanceDB（jira_issuesテーブル）
// ✅ ベクトルインデックス（IVF_PQ）
// ✅ Lunr.js（Jira専用インデックス）
// ✅ Firestore（生データ保存）
```

**評価**: ✅ ハイブリッドアプローチ（ベクトル検索 + 全文検索）を採用

---

### 5. 検索とランキング

#### 一般的な方法

**検索アプローチ**:

1. **純粋なベクトル検索**
   - コサイン類似度でランキング
   - **メリット**: 意味的類似性を捉える
   - **デメリット**: キーワード完全一致を捉えにくい

2. **ハイブリッド検索**
   - ベクトル検索 + BM25検索を組み合わせ
   - **メリット**: 意味的類似性とキーワード一致の両方を活用
   - **デメリット**: 実装が複雑

3. **RRF (Reciprocal Rank Fusion)**
   - 複数の検索結果を統合
   - **メリット**: 各検索手法の長所を活かせる
   - **デメリット**: パラメータ調整が必要

**メタデータフィルタリング**:
- ステータス、優先度、プロジェクト、アサインなどでフィルタリング
- 検索前（pre-filter）または検索後（post-filter）で適用

#### 現在の実装

```typescript
// 現在の実装（docs/01-architecture/02.01.01-hybrid-search-quick-reference.md）
// ✅ ベクトル検索（5%）
// ✅ BM25検索（53%）
// ✅ タイトル救済検索（26%）
// ✅ RRF融合（k=60）
// ✅ 複合スコアリング
```

**評価**: ✅ 高度なハイブリッドアプローチを実装

**特徴**:
- BM25を最優先（53%）: キーワード完全一致を重視
- タイトル救済検索: Issue Keyやタイトルマッチを強化
- 複合スコアリング: 複数のシグナルを統合

---

### 6. メタデータの扱い

#### 一般的な方法

**メタデータの種類**:
- **構造化メタデータ**: ステータス、優先度、Issue Key、作成日、更新日など
- **リレーショナルデータ**: 関連Issue、親子関係、リンクなど

**扱い方**:

1. **埋め込みに含める**
   - メタデータをテキストに変換して埋め込み
   - 例: "Status: Open, Priority: High, Issue Key: PROJ-123"

2. **別フィールドとして保存**
   - 埋め込みとは別に構造化データとして保存
   - フィルタリングやソートに使用

3. **ハイブリッドアプローチ**
   - 埋め込みにも含め、構造化データとしても保存
   - 両方の利点を活用

#### 現在の実装

```typescript
// 現在の実装（src/lib/lancedb-search-client.ts）
export interface LanceDBSearchResult {
  issue_key?: string;
  status?: string;
  priority?: string;
  assignee?: string;
  issue_type?: string;
  updated_at?: string;
  // ...
}
```

**評価**: ✅ ハイブリッドアプローチを採用
- 埋め込みにはメタデータを含む
- 構造化データとしても保存（検索後の補完処理で使用）

---

### 7. 時系列情報の扱い

#### 一般的な方法

**時系列データの活用**:

1. **ランキングへの組み込み**
   - 最新の情報にブースト（例: 更新日が新しいほどスコアに加算）
   - 時間減衰関数の適用（例: 指数減衰）

2. **フィルタリング**
   - 特定期間のIssueのみを検索対象に
   - 例: "過去1年のIssueのみ"

3. **ソートオプション**
   - デフォルトは関連性順、オプションで時系列順
   - 例: "新しい順"、"古い順"、"更新日順"

4. **経緯の追跡**
   - Issueの更新履歴を時系列で整理
   - コメントの時系列表示

#### 現在の実装

```typescript
// 現在の実装（docs/02-specifications/02.07-search-policy-and-timeline-handling.md）
// ❌ 時系列情報は保存されているが、ランキングに影響しない
// ❌ 時系列ソートオプションなし
```

**評価**: ⚠️ 改善の余地あり

**一般的なアプローチとの差分**:
- ✅ データとして保存: `updated_at`フィールド
- ❌ ランキングへの組み込み: 未実装
- ❌ 時系列ソート: 未実装
- ❌ 時間減衰: 未実装

---

### 8. コメントと履歴の扱い

#### 一般的な方法

**コメントの扱い**:

1. **Issue単位で統合**
   - すべてのコメントをIssueの説明と結合
   - **メリット**: Issue全体の文脈を保持
   - **デメリット**: 長くなる可能性

2. **個別チャンク**
   - 各コメントを個別のチャンクとして扱う
   - **メリット**: 細かい検索が可能
   - **デメリット**: Issueの文脈が失われる

3. **階層的構造**
   - Issue + 各コメントの両方を保存
   - 親子関係を保持

**履歴の扱い**:
- ステータス変更履歴、フィールド変更履歴を保持
- 経緯の追跡に使用

#### 現在の実装

```typescript
// 確認が必要（ドキュメントに明記されていない）
// おそらく: Issue単位で統合
```

**評価**: 確認が必要

---

## 📊 一般的なアプローチ vs 現在の実装 まとめ

| 項目 | 一般的なアプローチ | 現在の実装 | 評価 |
|------|------------------|-----------|------|
| **データ抽出** | Jira REST API | ✅ Jira REST API | ✅ 一致 |
| **前処理** | HTML除去、ノイズ除去 | ✅ HTML除去、正規化 | ✅ 一致 |
| **チャンキング** | Issue単位 or セマンティック | ❌ Issue単位（分割なし） | ⚠️ 長いIssueに注意 |
| **埋め込み** | Sentence-Transformers | ✅ Gemini Embeddings | ✅ 高品質 |
| **ベクトルDB** | FAISS / Pinecone / LanceDB | ✅ LanceDB | ✅ 最新アプローチ |
| **検索方式** | ベクトル or ハイブリッド | ✅ 高度なハイブリッド | ✅ 優れている |
| **メタデータ** | 埋め込み + 構造化 | ✅ ハイブリッド | ✅ 適切 |
| **時系列** | ランキング組み込み or ソート | ❌ 未実装 | ⚠️ 改善余地 |
| **コメント** | Issue統合 or 個別 | ⚠️ 確認必要 | ⚠️ 要確認 |

---

## 🎯 推奨される改善案

### 1. 時系列情報の活用（高優先度）

一般的なアプローチに合わせて、時系列情報をランキングに組み込む：

```typescript
// 提案: 軽微な最新性ブースト
const recencyBoost = calculateRecencyBoost(updated_at);
finalScore = finalScore * (1 + recencyBoost);
```

### 2. 長いIssueのチャンキング（中優先度）

コメントが多いIssueの場合、セマンティックチャンキングを検討：

```typescript
// 提案: コメント数が多い場合の分割
if (commentCount > 10 || contentLength > 2000) {
  // セマンティックチャンキングを適用
}
```

### 3. 時系列ソートオプション（中優先度）

UIで時系列ソートオプションを提供：

```typescript
// 提案: ユーザー選択可能なソート
[スコア順] [新しい順] [古い順]
```

### 4. コメントの扱いの明確化（低優先度）

コメントをどう扱っているかをドキュメント化：

- Issue単位で統合しているか
- 個別チャンクとして扱っているか
- 階層的構造を保持しているか

---

## 📚 参考資料

### 研究論文

1. **RAG4Tickets** (arXiv:2510.08667)
   - JiraとGitHubのデータを統合したRAGシステム
   - Sentence-TransformersとFAISSを使用
   - 過去のチケットやコメントを活用

2. **ER-RAG** (arXiv:2504.06271)
   - 異種データソース（Jira、GitHubなど）を統一的にモデル化
   - Entity-Relationshipモデルを活用

### 実装例

- **Sentence-Transformers**: テキスト埋め込みの生成
- **FAISS**: 高速なベクトル検索
- **LanceDB**: メモリ効率の良いベクトルデータベース

---

## 🔗 関連ドキュメント

- [Jira検索システム 仕様書](./02.03-jira-spec.md)
- [ConfluenceとJiraの比較](./02.04-confluence-jira-comparison.md)
- [検索方針と時系列情報の扱い](./02.07-search-policy-and-timeline-handling.md)
- [ハイブリッド検索 クイックリファレンス](../01-architecture/02.01.01-hybrid-search-quick-reference.md)

---

**最終更新日**: 2025-01-27  
**次回レビュー**: 改善実装完了時

