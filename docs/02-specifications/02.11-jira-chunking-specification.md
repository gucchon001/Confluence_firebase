# Jira Issue チャンク処理仕様

**作成日**: 2025-01-27  
**最終更新**: 2025-01-27  
**ステータス**: ✅ 仕様確定

---

## 📋 概要

JiraのIssueとコメント・変更履歴をチャンク分割する仕様を定義します。変更履歴を追加したことで、`content`フィールドが長くなる課題に対応するため、チャンク処理を実装します。

---

## 🎯 設計方針

### 基本原則

1. **条件付きチャンク分割**: 長いIssueのみをチャンク分割
2. **Confluenceとの一貫性**: Confluenceのチャンキング実装と同様の方式を採用
3. **階層的構造の保持**: Issue全体の文脈を保持しつつ、細かい検索を可能にする
4. **後方互換性**: 既存のIssue単位の検索も継続して動作する

---

## 📊 現状分析

### 現在の実装

**Jira**:
- Issue単位で1つのチャンクとして扱う
- `content`フィールドに以下を統合：
  - メタデータ
  - 説明（description）
  - 全コメント履歴（時系列順：古い順）
  - 変更履歴（時系列順：古い順）

**Confluence**:
- 1800文字でチャンク分割
- 200文字オーバーラップ（文脈保持）
- `chunkIndex`で階層的構造を保持

### 課題

1. **contentフィールドの長さ**:
   - コメントが多いIssue + 変更履歴が多いIssue = 非常に長い`content`フィールド
   - 例: コメント50件 + 変更履歴30件 = 5000文字以上になる可能性

2. **ベクトル化の品質**:
   - 長いテキストは埋め込み品質が低下する可能性
   - 検索精度に影響する可能性

3. **検索効率**:
   - 長いテキストは検索時にノイズが増える可能性

---

## 🔧 チャンク処理仕様

### 1. チャンク分割の条件（閾値）

#### オプションA: contentフィールドの文字数で判定 ✅ 推奨

**閾値**:
- `content`フィールドが**3000文字以上**の場合にチャンク分割

**メリット**:
- ✅ 実装がシンプル
- ✅ 実際のテキスト長に基づく判定
- ✅ コメント数や変更履歴数に依存しない

**デメリット**:
- ⚠️ テキスト生成後に判定する必要がある

**実装例**:
```typescript
const contentLength = sections.join('\n').length;
const shouldChunk = contentLength >= 3000;
```

---

#### オプションB: コメント数 + 変更履歴数で判定

**閾値**:
- コメント数が**30件以上**、または
- 変更履歴が**20件以上**、または
- コメント数 + 変更履歴数が**40件以上**

**メリット**:
- ✅ テキスト生成前に判定可能
- ✅ パフォーマンスが良い

**デメリット**:
- ⚠️ コメントや変更履歴の長さに依存しない
- ⚠️ 短いコメントが多い場合に不適切な分割になる可能性

**実装例**:
```typescript
const commentCount = issue.allComments?.length || 0;
const changelogCount = issue.changelog?.length || 0;
const shouldChunk = commentCount >= 30 || changelogCount >= 20 || (commentCount + changelogCount) >= 40;
```

---

#### オプションC: 両方の条件を組み合わせ

**閾値**:
- `content`フィールドが**3000文字以上**、または
- コメント数 + 変更履歴数が**40件以上**

**メリット**:
- ✅ より柔軟な判定
- ✅ 両方の観点を考慮

**デメリット**:
- ⚠️ 実装が複雑

---

**決定**: **オプションA（contentフィールドの文字数で判定）** ✅ 確定

**理由**:
1. ✅ 実装がシンプルで保守性が高い
2. ✅ 実際のテキスト長に基づく判定が適切
3. ✅ Confluenceの実装と一貫性がある

**実装状況**: ⚠️ 実装予定

---

### 2. チャンク分割方法

#### チャンクサイズ

**推奨値**:
- **チャンクサイズ**: 1800文字（Confluenceと同様）
- **オーバーラップ**: 200文字（文脈保持）

**理由**:
- Confluenceの実装と一貫性を保つ
- RAG標準: 512-1,024トークン（約2,000～4,000文字）の範囲内

---

#### 分割方法

**方法**: テキストを固定サイズで分割（Confluenceと同様）

**実装例**:
```typescript
function splitIntoChunks(text: string, chunkSize: number = 1800, overlap: number = 200): string[] {
  const chunks: string[] = [];
  let start = 0;
  
  while (start < text.length) {
    const end = Math.min(start + chunkSize, text.length);
    const chunk = text.substring(start, end).trim();
    
    if (chunk.length > 0) {
      chunks.push(chunk);
    }
    
    // 次のチャンクはoverlapだけ前から開始（文脈を保持）
    start = end - overlap;
    
    // 最後のチャンクに到達した場合は終了
    if (start + chunkSize >= text.length && chunks.length > 0) {
      break;
    }
  }
  
  return chunks.length > 0 ? chunks : [text];
}
```

**特徴**:
- 固定サイズで分割（シンプル）
- オーバーラップで文脈を保持
- 最後のチャンクは残りすべてを含む

---

### 3. チャンクの構造

#### LanceDBレコード構造

**現在の構造**:
```typescript
interface LanceDbRecord {
  id: string;              // issue_key
  issue_key: string;
  title: string;
  content: string;
  vector: number[];
  // ... その他のフィールド
}
```

**チャンク分割後の構造**:
```typescript
interface LanceDbRecord {
  id: string;              // issue_key (チャンク分割なし) または issue_key-chunkIndex (チャンク分割あり)
  issue_key: string;       // 元のIssue Key
  title: string;           // Issueタイトル（全チャンクで同じ）
  content: string;         // チャンクの内容
  vector: number[];
  isChunked: boolean;      // チャンク分割されているかどうか
  chunkIndex?: number;     // チャンクのインデックス（0, 1, 2, ...）
  totalChunks?: number;    // 総チャンク数
  // ... その他のフィールド
}
```

**IDの生成方法**:
- チャンク分割なし: `id = issue_key`（例: "CTJ-1234"）
- チャンク分割あり: `id = ${issue_key}-${chunkIndex}`（例: "CTJ-1234-0", "CTJ-1234-1"）

---

### 4. チャンク分割の実装方針

#### オプションA: Issue全体をチャンク分割 ✅ 推奨

**方法**:
- `content`フィールド全体（メタデータ + 説明 + コメント + 変更履歴）をチャンク分割
- 各チャンクにタイトルを含める（Confluenceと同様）

**メリット**:
- ✅ 実装がシンプル
- ✅ Confluenceと一貫性がある
- ✅ Issue全体の文脈を保持

**デメリット**:
- ⚠️ チャンク境界で文脈が切れる可能性

**実装例**:
```typescript
// contentフィールド全体をチャンク分割
const content = sections.join('\n');
const chunks = splitIntoChunks(content, 1800, 200);

// 各チャンクにタイトルを含める（Confluenceと同様）
const chunksWithTitle = chunks.map((chunk, index) => ({
  id: chunks.length > 1 ? `${issue.key}-${index}` : issue.key,
  issue_key: issue.key,
  title: issue.summary,
  content: chunk,
  isChunked: chunks.length > 1,
  chunkIndex: chunks.length > 1 ? index : undefined,
  totalChunks: chunks.length > 1 ? chunks.length : undefined,
  // ... その他のフィールド
}));
```

---

#### オプションB: セマンティックチャンキング

**方法**:
- Issue全体チャンク + コメント個別チャンク + 変更履歴個別チャンクの3種類を保存
- 階層的構造を保持

**メリット**:
- ✅ より細かい検索が可能
- ✅ コメントや変更履歴のみを対象とした検索が可能

**デメリット**:
- ❌ 実装が複雑
- ❌ ストレージコストが増加
- ❌ 検索結果の重複が発生する可能性

---

**決定**: **オプションA（Issue全体をチャンク分割）** ✅ 確定

**理由**:
1. ✅ 実装がシンプルで保守性が高い
2. ✅ Confluenceと一貫性がある
3. ✅ Issue全体の文脈を保持できる

**実装状況**: ⚠️ 実装予定

---

### 5. 検索への影響

#### ベクトル検索

**現在の実装**:
- Issue単位で1つのベクトルとして検索

**チャンク分割後**:
- 各チャンクが個別のベクトルとして検索される
- 複数のチャンクが検索結果に含まれる可能性
- `enrichWithAllChunks`関数でチャンクを統合（Confluenceと同様）

**実装例**:
```typescript
// 検索結果に複数のチャンクが含まれる場合
const results = [
  { id: 'CTJ-1234-0', issue_key: 'CTJ-1234', chunkIndex: 0, ... },
  { id: 'CTJ-1234-1', issue_key: 'CTJ-1234', chunkIndex: 1, ... },
  { id: 'CTJ-1234-2', issue_key: 'CTJ-1234', chunkIndex: 2, ... }
];

// enrichWithAllChunksで統合
const enriched = await enrichWithAllChunks(results);
// → { id: 'CTJ-1234', issue_key: 'CTJ-1234', content: '全チャンクを統合した内容', ... }
```

---

#### BM25検索

**現在の実装**:
- Issue単位で1つのレコードとして検索

**チャンク分割後**:
- 各チャンクが個別のレコードとして検索される
- Lunr.jsインデックスに各チャンクが登録される
- 検索結果で複数のチャンクが返される可能性

**実装例**:
```typescript
// Lunr.jsインデックスに各チャンクを登録
chunks.forEach((chunk, index) => {
  index.add({
    id: chunks.length > 1 ? `${issue.key}-${index}` : issue.key,
    title: issue.summary,
    content: chunk.content,
    issue_key: issue.key,
    chunkIndex: chunks.length > 1 ? index : undefined
  });
});
```

---

### 6. チャンク統合処理

#### Confluenceの実装を参考

**現在の実装**（`src/ai/flows/retrieve-relevant-docs-lancedb.ts`）:
```typescript
export async function enrichWithAllChunks(results: any[]): Promise<any[]> {
  // Jiraレコードの場合はチャンク統合をスキップ（Jiraはチャンク分割されていない）
  if (isJiraRecord) {
    return {
      ...result,
      content: removeBOM(result.content || ''),
      title: removeBOM(result.title || ''),
    };
  }
  
  // isChunkedフラグによる条件分岐
  if (result.isChunked === false) {
    // チャンク分割されていないページ → 統合不要
    return result;
  }
  
  // チャンク統合処理
  const allChunks = await getAllChunksByPageId(String(pageId));
  // ...
}
```

**Jira対応**:
- `isChunked`フラグを追加
- `isChunked === true`の場合、同じ`issue_key`の全チャンクを取得して統合
- `enrichWithAllChunks`関数をJira対応に拡張

---

## 📝 実装仕様まとめ

### チャンク分割条件 ✅ 決定済み

| 条件 | 閾値 | 判定タイミング | 実装状況 |
|------|------|--------------|---------|
| **contentフィールドの文字数** | 3000文字以上 | テキスト生成後 | ⚠️ 実装予定 |

### チャンク分割パラメータ ✅ 決定済み

| パラメータ | 値 | 備考 | 実装状況 |
|-----------|-----|------|---------|
| **チャンクサイズ** | 1800文字 | Confluenceと同様 | ⚠️ 実装予定 |
| **オーバーラップ** | 200文字 | 文脈保持 | ⚠️ 実装予定 |

### データ構造 ✅ 決定済み

| フィールド | 型 | 説明 | 実装状況 |
|-----------|-----|------|---------|
| `id` | string | `issue_key` (チャンク分割なし) または `issue_key-chunkIndex` (チャンク分割あり) | ⚠️ 実装予定 |
| `issue_key` | string | 元のIssue Key | ✅ 既存フィールド |
| `isChunked` | boolean | チャンク分割されているかどうか | ⚠️ 実装予定 |
| `chunkIndex` | number? | チャンクのインデックス（0, 1, 2, ...） | ⚠️ 実装予定 |
| `totalChunks` | number? | 総チャンク数 | ⚠️ 実装予定 |

### 検索への影響

| 検索方式 | 影響 | 対応 |
|---------|------|------|
| **ベクトル検索** | 各チャンクが個別に検索される | `enrichWithAllChunks`で統合 |
| **BM25検索** | 各チャンクが個別に検索される | `enrichWithAllChunks`で統合 |

---

## 🔄 実装フロー

### チャンク分割の実装フロー

```
1. Issueデータを正規化
   ↓
2. contentフィールドを構築
   ↓
   メタデータ + 説明 + コメント履歴 + 変更履歴
   ↓
3. contentフィールドの文字数をチェック
   ↓
   if (content.length >= 3000) {
     チャンク分割を実行
   } else {
     チャンク分割なし（既存の実装）
   }
   ↓
4. チャンク分割（1800文字、200文字オーバーラップ）
   ↓
5. 各チャンクにメタデータを付与
   ↓
   - id: issue_key-chunkIndex
   - isChunked: true
   - chunkIndex: 0, 1, 2, ...
   - totalChunks: 3
   ↓
6. 各チャンクをベクトル化
   ↓
7. LanceDBに保存
   ↓
   各チャンクが個別のレコードとして保存
```

---

## 🚀 実装優先度

### 優先度: 高 ⚠️ 重要

**理由**:
- 変更履歴を追加したことで、`content`フィールドが長くなる課題が顕在化
- ベクトル化の品質と検索精度に影響する可能性
- 次回の同期前に実装を推奨

**実装時期**: 変更履歴実装後、次回の同期前に実装推奨

---

## 🔗 関連ドキュメント

- `docs/02-specifications/02.10-jira-changelog-search-integration-spec.md`: 変更履歴の検索統合仕様
- `docs/02-specifications/02.09-jira-comments-and-history-implementation-details.md`: コメントと履歴の実装詳細
- `src/lib/confluence-sync-service.ts`: Confluenceのチャンキング実装（参考）
- `src/lib/text-chunking.ts`: テキストチャンキングユーティリティ
- `src/ai/flows/retrieve-relevant-docs-lancedb.ts`: チャンク統合処理（参考）

---

---

## 🎯 仕様決定サマリー

### 決定済み事項

1. ✅ **チャンク分割条件**: contentフィールドが3000文字以上
2. ✅ **チャンクサイズ**: 1800文字、200文字オーバーラップ
3. ✅ **チャンク分割方法**: Issue全体をチャンク分割（オプションA）
4. ✅ **データ構造**: `id = issue_key-chunkIndex`, `isChunked`, `chunkIndex`, `totalChunks`

### 実装予定

- ⚠️ チャンク分割ロジックの実装
- ⚠️ `isChunked`, `chunkIndex`, `totalChunks`フィールドの追加
- ⚠️ `enrichWithAllChunks`関数のJira対応
- ⚠️ Lunr.jsインデックスのチャンク対応

---

**最終更新日**: 2025-01-27  
**仕様確定日**: 2025-01-27  
**次回レビュー**: 実装開始時

