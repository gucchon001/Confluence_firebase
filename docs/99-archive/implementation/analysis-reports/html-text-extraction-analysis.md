# HTMLテキスト抽出処理の分析

## 概要

ConfluenceのドキュメントはHTML形式で保存されており、それをテキスト化してLanceDBに保存しています。
この処理が正しく行われているか、特に表の処理について調査します。

## 現在の実装

### 1. HTMLからテキスト抽出 (`extractTextFromHtml`)

**ファイル**: `src/lib/confluence-sync-service.ts` (909-937行目)

```typescript
private extractTextFromHtml(html: string): string {
  if (!html) return '';
  
  // BOM文字（U+FEFF）を削除
  let text = removeBOM(html);
  
  // HTML特殊文字をデコード
  const htmlEntities: { [key: string]: string } = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&nbsp;': ' ',
    '&apos;': "'"
  };
  
  for (const [entity, char] of Object.entries(htmlEntities)) {
    text = text.replace(new RegExp(entity, 'g'), char);
  }
  
  // HTMLタグを削除して空白に置換
  const withoutTags = text.replace(/<[^>]*>/g, ' ');
  
  // 連続する空白を1つにまとめる
  const normalizedSpaces = withoutTags.replace(/\s+/g, ' ');
  
  // 前後の空白を削除
  return this.sanitizeText(normalizedSpaces);
}
```

### 2. 処理フロー

1. **HTMLタグの削除**: `<[^>]*>`を空白に置換
2. **空白の正規化**: 連続する空白を1つにまとめる
3. **BOM文字の削除**: `\uFEFF`を削除

## 問題点

### 問題1: 表の構造が失われる ✅ 確認済み

**テスト結果**:

入力:
```html
<table><tr><td>更新前</td><td>更新後</td></tr><tr><td>学部1年生</td><td>学部2年生</td></tr></table>
```

出力:
```
更新前 更新後 学部1年生 学部2年生
```

文字数: 19文字

**問題**:
- ❌ 表のセル間の区切りが空白になってしまう
- ❌ 行の区切りが失われる
- ❌ 表の構造（どのセルがどの列か）が分からなくなる
- ❌ キーワードマッチングで表の内容を正しく検出できない可能性

### 問題2: 文字数カウントの不正確性

**影響**:
- HTMLタグを削除して空白に置換するため、実際の文字数とカウントが異なる可能性
- 表の場合は、セル間の空白が追加されるため、文字数が増える可能性
- ただし、HTMLタグ自体は削除されるため、全体的には文字数は減る

### 問題3: チャンク分割時の表の分割

**影響**:
- 表がチャンクの境界で分割される可能性
- 表の一部だけが抽出される可能性
- 表の構造が失われているため、分割の影響が大きい

## 比較: Jiraの処理

**ファイル**: `src/lib/jira-sync-service.ts` (407-445行目)

```typescript
private extractTextFromADF(node: any): string {
  // ...
  case 'table':
    return (node.content || [])
      .map((row: any) => (row.content || [])
        .map((cell: any) => this.extractTextFromADF(cell).trim())
        .join(' | '))  // セル間を ' | ' で区切る
      .join('\n');     // 行間を改行で区切る
  // ...
}
```

**Jiraの処理**:
- ✅ 表のセル間を ` | ` で区切る
- ✅ 行間を改行で区切る
- ✅ 表の構造が保持される

**例**:
```
更新前 | 更新後
学部1年生 | 学部2年生
```

## 改善案

### 案1: 表の構造を考慮したHTML処理（推奨）

HTMLからテキストを抽出する際に、表の構造を考慮する。

```typescript
private extractTextFromHtml(html: string): string {
  if (!html) return '';
  
  let text = removeBOM(html);
  
  // HTML特殊文字をデコード
  const htmlEntities: { [key: string]: string } = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&nbsp;': ' ',
    '&apos;': "'"
  };
  
  for (const [entity, char] of Object.entries(htmlEntities)) {
    text = text.replace(new RegExp(entity, 'g'), char);
  }
  
  // 表の処理を優先（構造を保持）
  text = text.replace(/<table[^>]*>([\s\S]*?)<\/table>/gi, (match, tableContent) => {
    // 表の各行を処理
    const rows: string[] = [];
    const rowMatches = tableContent.match(/<tr[^>]*>([\s\S]*?)<\/tr>/gi) || [];
    
    for (const rowMatch of rowMatches) {
      // 各セルを処理
      const cells: string[] = [];
      const cellMatches = rowMatch.match(/<t[dh][^>]*>([\s\S]*?)<\/t[dh]>/gi) || [];
      
      for (const cellMatch of cellMatches) {
        // セル内のHTMLタグを削除してテキストを抽出
        let cellText = cellMatch.replace(/<[^>]*>/g, ' ');
        cellText = cellText.replace(/\s+/g, ' ').trim();
        cells.push(cellText);
      }
      
      if (cells.length > 0) {
        rows.push(cells.join(' | '));
      }
    }
    
    return rows.join('\n');
  });
  
  // その他のHTMLタグを削除
  text = text.replace(/<[^>]*>/g, ' ');
  
  // 空白の正規化
  text = text.replace(/\s+/g, ' ');
  
  return this.sanitizeText(text);
}
```

**期待される結果**:
```
更新前 | 更新後
学部1年生 | 学部2年生
```

### 案2: HTMLパーサーライブラリの使用

`cheerio`や`jsdom`などのHTMLパーサーライブラリを使用して、より正確にHTMLを処理する。

**メリット**:
- より正確なHTML処理
- 複雑なHTML構造にも対応

**デメリット**:
- 依存関係の追加
- パフォーマンスの影響

### 案3: Confluence APIのストレージ形式を確認

Confluence APIが返すHTMLの形式を確認し、表がどのように表現されているかを調査する。

## 調査が必要な点

1. **Confluence APIのレスポンス形式**
   - ✅ 表がHTML形式で表現されている（`<table>`, `<tr>`, `<td>`）
   - ❓ 表の構造が複雑な場合の処理
   - ❓ ネストされた表の処理

2. **現在のデータ**
   - ❓ LanceDBに保存されているデータを確認
   - ❓ 表の内容が正しく保存されているか
   - ❓ 文字数カウントが正確か

3. **テストケース**
   - ✅ 表を含むドキュメントでテスト（`test-grade-update-extraction.ts`）
   - ❓ 表の内容が正しく抽出されているか
   - ❓ 文字数カウントが正確か

## 影響範囲

### コンテンツ抽出ロジックへの影響

1. **キーワードマッチング**
   - 表の構造が失われているため、表内のキーワードを正しく検出できない可能性
   - 例: 「更新前」「更新後」が検出されても、表の構造が分からない

2. **文字数カウント**
   - 表の構造が失われているため、実際の文字数とカウントが異なる可能性
   - ただし、HTMLタグは削除されるため、全体的には文字数は減る

3. **チャンク分割**
   - 表がチャンクの境界で分割される可能性
   - 表の一部だけが抽出される可能性

## 実際のデータ確認結果 ✅

### 確認したデータ

**対象ドキュメント**: 721_【作成中】学年自動更新バッチ（ページID: 743473812）
- 総チャンク数: 1
- 総文字数: 1600文字

### 発見事項

#### 1. 表の構造が失われている ✅ 確認済み

**表の構造確認**:
- HTMLタグ（<table>, <tr>, <td>）: ❌ なし（テキスト化済み）
- セル区切り（ | ）: ❌ なし（構造が失われている）
- 改行（\n）: ❌ なし

**表の内容例**:
```
表2 学年の更新内容 更新前 更新後 入学見込み 学部1年生 学部1年生 学部2年生 学部2年生 学部3年生 学部3年生 ...
```

**問題**:
- セル間の区切りが空白になっている
- 行の区切りが失われている
- 表の構造が単なる文字列として扱われている

#### 2. 表の内容は存在する ✅

**キーワードの位置**:
- 「表1」: 502文字目 ✅
- 「表2」: 555文字目 ✅
- 「更新前」: 944文字目 ✅
- 「更新後」: 948文字目 ✅
- 「学部1年生」: 958文字目 ✅
- 「学部2年生」: 846文字目（複数箇所） ✅
- 「現在の職業の更新」: 1092文字目 ✅

**表1の周辺**:
```
表1の条件 を満たしている。 入学からの経過年数 = 当年 - 「入学年・月：年」 抽出した会員において、表2の 学年更新処理 を行う。 「大学：学年」を下記表の通り更新する。 「学年更新日」に実行日を入れる。 「学年更新ステータス」に 2 を入れる。 表1 「入学からの経過年数」ごとの対象判定条件 入学からの経過 年数 対象となる条件 7 以上 対象外 6 「大学：学年」が「学部6年生」 5 「大...
```

**表2の周辺**:
```
表2の 学年更新処理 を行う。 「大学：学年」を下記表の通り更新する。 「学年更新日」に実行日を入れる 。 「学年更新ステータス」に 2 を入れる。 表1 「入学からの経過年数」ごとの対象判定条件 入学からの経過年数 対象となる条件 7 以上 対象外 6 「大学：学年」が「学部6年生」 5 「大学：学年」が「学部6年生 」ではない 4 「大学：学年」が「学部5年生」「学部6年生」ではない 3 「大学：...
```

#### 3. コンテンツ抽出ロジックへの影響

**現在の抽出ロジック（600文字制限）**:
- 先頭から600文字を取得
- 「表1」（502文字目）は含まれる ✅
- 「表2」（555文字目）は含まれる ✅
- 「更新前」「更新後」（944-948文字目）は範囲外 ❌
- 「現在の職業の更新」（1092文字目）は範囲外 ❌

**問題**:
- 表の構造が失われているため、表の中身が先頭から600文字の範囲外にある
- キーワードマッチングで「更新前」「更新後」を検出できない可能性
- 範囲外のキーワードを含める際の調整ロジックが正しく動作していない可能性

## 次のステップ

1. ✅ **問題の確認**: 表の構造が失われていることを確認
2. ✅ **実際のデータ確認**: 表の内容が正しく保存されていることを確認
3. ⏳ **改善案の実装**: 表の構造を考慮したHTML処理を実装
4. ⏳ **コンテンツ抽出ロジックの改善**: 範囲外キーワードを含める際の調整ロジックを改善
5. ⏳ **テスト**: 表を含むドキュメントでテスト
6. ⏳ **検証**: コンテンツ抽出ロジックが正しく動作するか確認
