# Jira検索時のFirestore連携設計

**作成日**: 2025-01-27  
**目的**: 検索時にFirestoreから追加情報（カスタムフィールド、全コメント履歴等）を取得して検索結果を補完する仕組みを設計

---

## 1. 目的

検索結果のLanceDBデータを、Firestoreに保存されている詳細情報で補完する：
- カスタムフィールド（現在LanceDBに保存されていないもの）
- 全コメント履歴（LanceDBには最新コメントのみ）
- `rawJson`からの追加メタデータ

---

## 2. 現在の状況

### 2.1 検索フロー（現在）

```
ユーザークエリ
  ↓
HybridSearchEngine.search()
  ↓
LanceDB検索（ベクトル + BM25）
  ↓
検索結果（LanceDBから直接取得）
  ↓
APIレスポンス
```

### 2.2 Firestoreに保存されているデータ

- **コレクション**: `jiraIssues`
- **ドキュメントID**: `issueKey`（例: `CTJ-5439`）
- **フィールド**:
  - `rawJson`: Jiraレスポンス全体（JSON文字列）
  - `comments`: 全コメント履歴（配列）
  - `normalized`: 正規化されたデータ（カスタムフィールド含む）
  - `syncedAt`: 同期日時

---

## 3. 設計方針

### 3.1 基本方針

1. **パフォーマンス重視**: バッチ取得でFirestoreへのアクセスを最小化
2. **段階的実装**: まずはカスタムフィールドとコメント履歴の補完から
3. **フォールバック**: Firestore取得に失敗しても、LanceDBのデータで動作を継続

### 3.2 実装場所

- **検索API**: `/api/search`ルート
- **ストリーミングAPI**: `/api/streaming-process`ルート

---

## 4. 実装設計

### 4.1 Firestore補完サービスの作成

**ファイル**: `src/lib/jira-firestore-enrichment-service.ts`

```typescript
interface FirestoreEnrichmentService {
  /**
   * 検索結果をFirestoreから取得したデータで補完
   * @param results LanceDBからの検索結果
   * @param limit 補完する最大件数（パフォーマンス考慮）
   * @returns 補完された検索結果
   */
  enrichSearchResults(
    results: LanceDBSearchResult[],
    limit?: number
  ): Promise<EnrichedSearchResult[]>;
}
```

### 4.2 補完するデータ

1. **カスタムフィールド**:
   - `month` (customfield_10276)
   - `customAssignee` (customfield_10277)
   - `gigStatus` (customfield_10278)
   - `releaseDate` (customfield_10281)
   - `completedDate` (customfield_10282)
   - `desiredReleaseDate` (customfield_10283)
   - `deadlineReleaseDate` (customfield_10284)
   - その他のカスタムフィールド

2. **コメント履歴**:
   - `comments`: 全コメント履歴（配列）

3. **追加メタデータ**:
   - `rawJson`: 必要に応じて解析

### 4.3 実装フロー

```
検索結果（LanceDB）
  ↓
issue_keyを抽出（最大10件）
  ↓
Firestoreからバッチ取得
  ↓
カスタムフィールド・コメントを補完
  ↓
検索結果にマージ
  ↓
APIレスポンス
```

---

## 5. パフォーマンス考慮

### 5.1 バッチ取得

- Firestoreの`getAll()`を使用して、複数のドキュメントを一度に取得
- 最大10件まで補完（検索結果の上限に合わせる）

### 5.2 エラーハンドリング

- Firestore取得に失敗した場合、LanceDBのデータのみでレスポンスを返す
- エラーログを記録するが、ユーザーには影響を与えない

### 5.3 キャッシュ（将来の最適化）

- 頻繁に検索される課題はメモリキャッシュ
- キャッシュの有効期限を設定（例: 5分）

---

## 6. 実装ステップ

### Step 1: Firestore補完サービスの作成
- `src/lib/jira-firestore-enrichment-service.ts`を作成
- 基本的な`enrichSearchResults`メソッドを実装

### Step 2: 検索APIへの統合
- `/api/search`ルートに補完処理を追加
- Jira検索結果に対してのみ補完を実行

### Step 3: ストリーミングAPIへの統合
- `/api/streaming-process`ルートに補完処理を追加

### Step 4: テスト
- 少数レコードでテスト
- パフォーマンステスト

---

## 7. データ構造

### 7.1 補完前（LanceDB）

```typescript
interface LanceDBSearchResult {
  id: string;
  issue_key: string;
  title: string;
  content: string;
  status: string;
  priority: string;
  // ... 基本的なフィールドのみ
}
```

### 7.2 補完後（Enriched）

```typescript
interface EnrichedSearchResult extends LanceDBSearchResult {
  // カスタムフィールド
  customFields?: {
    month?: string;
    customAssignee?: string;
    gigStatus?: string;
    releaseDate?: string;
    completedDate?: string;
    desiredReleaseDate?: string;
    deadlineReleaseDate?: string;
  };
  // 全コメント履歴
  comments?: Array<{
    id?: string;
    author: string;
    created: string;
    body: string;
  }>;
  // その他のメタデータ
  metadata?: {
    syncedAt?: Date;
  };
}
```

---

## 8. 注意事項

1. **データ整合性**: FirestoreとLanceDBのデータが一致しない場合の処理
2. **パフォーマンス**: Firestore取得による検索速度への影響を最小化
3. **スケーラビリティ**: 大量の検索リクエストに対する対応

