# APIレスポンスへの影響分析

## 📊 分析結果

### APIレスポンスでの`pageId`使用状況

#### 1. `/api/search` エンドポイント (`src/app/api/search/route.ts`)

**現在の実装**:
```typescript
const formattedResults = hybridResults.map(result => ({
  id: `${result.pageId}-0`, // ← pageIdを使用してidを生成
  title: result.title,
  content: result.content,
  // pageIdフィールドは直接返していない
}));
```

**影響**:
- ✅ **低い**: APIレスポンスには`pageId`フィールドが含まれていない
- ✅ **互換性**: `id`フィールドとして`${result.pageId}-0`形式で返している
- ⚠️ **注意**: 内部処理での`result.pageId`への参照は変更が必要

#### 2. `/api/streaming-process` エンドポイント

**確認が必要**: ストリーミングレスポンスでの`pageId`使用状況

#### 3. その他のAPIエンドポイント

**確認が必要**: 他のエンドポイントでの`pageId`使用状況

## 🔍 推奨アプローチ

### オプション1: 内部処理のみ変更（推奨）
- **内部処理**: `page_id`を使用（データベースフィールド名）
- **APIレスポンス**: `pageId`を維持（互換性を保つ）
- **変換レイヤー**: データベースから取得時に`page_id`→`pageId`に変換

**メリット**:
- ✅ フロントエンド側への影響なし
- ✅ 既存のAPIクライアントとの互換性維持
- ✅ 段階的な移行が可能

**デメリット**:
- ⚠️ 変換レイヤーの実装が必要
- ⚠️ コードの複雑性が増加

### オプション2: APIレスポンスも変更
- **内部処理**: `page_id`を使用
- **APIレスポンス**: `page_id`に変更

**メリット**:
- ✅ 一貫性がある
- ✅ 変換レイヤーが不要

**デメリット**:
- ❌ フロントエンド側の修正が必要
- ❌ 既存のAPIクライアントとの互換性が失われる
- ❌ 段階的な移行が困難

## 📋 実装推奨

### Phase 1: 内部処理の変更
1. データベーススキーマ: `pageId` → `page_id`
2. データベースクエリ: `pageId` → `page_id`
3. 内部型定義: `pageId` → `page_id`

### Phase 2: APIレスポンスの変換レイヤー
1. データベースから取得時に`page_id`を`pageId`に変換
2. APIレスポンスでは`pageId`を維持

### Phase 3: テストと検証
1. APIレスポンスのテスト
2. フロントエンド側の動作確認

